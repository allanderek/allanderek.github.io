<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<base href="https://allanderek.github.io/">
<meta name="description" content="My quest to stop writing too much code.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Coding Diet</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://allanderek.github.io/">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/dynamically-typed-languages-why/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://allanderek.github.io/">

                <span id="blog-title">Coding Diet</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS feed</a>
                </li>
<li>
<a href="stories/curriculum-vitae/">CV</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    
<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/dynamically-typed-languages-why/" class="u-url">In what ways are dynamically typed languages more productive?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/dynamically-typed-languages-why/" rel="bookmark"><time class="published dt-published" datetime="2016-05-04T20:41:57+01:00" title="2016-05-04 20:41">2016-05-04 20:41</time></a></p>
                <p class="commentline">
        
    <a href="posts/dynamically-typed-languages-why/#disqus_thread" data-disqus-identifier="cache/posts/dynamically-typed-languages-why.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Introduction</h2>
<p>I do not aim to answer the question in the title more raise the question.
The question kind of implies that dynamically typed languages are more
productive in at least some ways. It does not imply that statically typed
languages are less productive in general, or the opposite.</p>
<p>Before going any further, I'm talking about the distinction between static
and dynamic typing which is not the same as strong vs weak typing. Static
means the type checking is done at compilation before the program is run, whilst
dynamic means types are checked whilst the program is running. Not the same as
weak vs strong typing and also not the same as explicit vs implicit typing.</p>
<h2>Background</h2>
<p>My PhD involved the development of a novel static type
system. When I begun my PhD I was firmly of the opinion that
statically typed languages were better than dynamically typed
languages. My basic contention was that all the guarantees you get
from static types you get largely for free, so throwing those away is a
stupefying act of self harm. I believe that prior to the turn of the
century (if not a bit later), this the majority view in programming language
research. It is still a position commonly held but I'm unsure whether it may
still be a majority view or not.</p>
<p>New data, should force us to seek out new theories which explain
all of the available data. In the past 20 years, one thing is obvious.
Dynamically typed languages have seen significant growth and success.
Some researchers choose to ignore this. Some explain the success as a
fluke, that such languages have become popular <em>despite</em> being
dynamically typed. This is a recurrence of an argument made by
functional programmers/researchers when C++ and then Java became wildly popular.</p>
<p>The prevailing view amongst researchers was that functional languages were inherently
better than Java, but Java got a lot of financial support which meant
that a lot of support was added to, in particular, the standard
library. This meant that programmers were particularly productive
using Java, but that that increase in productivity was mis-attributed
by the programmers to the language, when it should have been placed
firmly in the excellent standard library support. Much of this support
is work that open source programmers are not quite so keen on, because
frankly, it's a bit boring and unrewarding. I personally find this
argument at least lightly compelling.</p>
<p>However, in the first decade of this century, as I said, dynamically typed
languages have had at least significant success. Python, PHP,
and Ruby are the most obvious examples. None of these were backed
financially by any large corporation, at least not prior to their success.
I again suspect that much of the productivity gained with the use of such
languages can be placed in the library support. But that does not explain
where the library support has come from. If dynamically typed languages were so
obviously counter-productive, then why did anyone waste their time
writing library support code in-and-for them?</p>
<h2>Some Wild Hypotheses Appear</h2>
<p>I am now going to state some hypotheses to explain this. This does not mean
I endorse any of these.</p>
<h3>Short term vs Long Term</h3>
<p>One possible answer. Dynamically typed languages increase <em>short term</em>
productivity at the cost of <em>long term</em> productivity. I don't personally
believe this but I do find it plausible. However, I do not know of any
evidence for or against this position. I'm not even sure there is much
of a logical argument for it.</p>
<p>The kinds of bugs that functional programming languages help prevent
are the kind of bug that is hard to demonstrate. It is easy enough to show
a bug in an imperative program that would not occur in a functional program
because you do not have mutable state. However, such demonstration bugs
tend to be a bit contrived, and it is hard to show that such bugs come up in
real code frequently. On top of that, to show that functional languages are
more productive one would have to show that by restricting mutable state you
do not lose more productivity than you gain by avoiding such bugs. If you did
manage to show this, you would have a reasonable argument that functional
languages are bad for short-term productivity, due to the restrictions on
mutable state changes, but compensate in greater long-term productivity.</p>
<p>So, a similar kind of argument could be made for statically typed languages.
If you could show that statically typed languages prevent a certain class of
bugs and that the long-term productivity gained from that is more than enough
to compensate for any short-term loss in productivity brought on by restrictions
due to the type-system.</p>
<p>So I will leave my verdict on this hypothesis as, I believe it to be false
but it is plausible. Just to note, there is no great evidence that <em>either</em>
statically typed languages have greater long-term productivity,
<strong>or</strong> that dynamically typed languages have greater short-term productivity.</p>
<h3>Testing Tools</h3>
<p>A trend that seems to have tracked (ie. correlates with, either via
causation in either direction or by coincidence) the trend in use of
(and success of) dynamically typed languages is the trend towards more
rigorous testing, or rather the rise in popularity of more rigorous testing.
In particular test-driven development style methodologies have gained
significant support.</p>
<p>I believe that having a comprehensive test suite, somewhat dilutes the
benefits gained from a static type system. Here is a good challenge,
try to find a bug that is caught by the type checker, that would not be
caught by a test suite with 100% code coverage.</p>
<p>One possibility is an exhaustive pattern match, however, if your test suite
is not catching this, it's not a great test suite. Still, exhaustive pattern
match tests is something you get more or less for free with a static type checker,
whilst a test suite has to work at it.</p>
<p>It is certainly possible to come up with a bug that is caught by static type checking
and not by a test suite that has full coverage. Here is an example:</p>
<pre class="code literal-block"><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s2">"1"</span>
    <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
</pre>


<p>This is a bug, because <code>b</code> might be true, whilst <code>a</code> is false. Which
would mean that <code>x</code> is set to a string, but later treated as an integer,
because <code>b</code> is true. A good test suite, will of course catch
this bug. But it is still possible to achieve 100% code coverage (at
the statement) level, and <em>not</em> catch this bug. Still, you have to try
quite hard to arrange this.</p>
<p><a href="http://en.wikipedia.org/wiki/Mutation_testing">Mutation testing</a>,
which tests your tests, rather than your implementation code, should
catch this simple example (because it will mutate the condition
<code>(a and b)</code> to be <code>(a or b)</code> which won't make any difference if your tests
never caught the bug initially. This will mean that the mutant will
pass all tests, and you should at that point realise your tests are
not comprehensive enough.</p>
<h3>Dynamically Typed Language Benefits</h3>
<p>So you should have a comprehensive test suite for all code whether you are
using a statically or dynamically typed language. We may then accept the
theory that a comprehensive test suite somewhat dilutes any benefits of using
a statically typed language. However, that theory does not give any reasaon why
a static type system is detrimental to productivity.</p>
<p>This was always my main contention, that whatever might
be the benefits of static typing, you are getting them for free, so
why not? I honestly do not know what, if any, benefit there is from
having a dynamic type system. I can think of some plausible
candidates, but have no evidence that any of these are true:</p>
<ol>
<li>Freeing the <em>language</em> from a type system, allows the language
designers to include some productivity boosting features that are not
available in a statically typed language. I find this suggestion a little weak,
no one has ever been able to point me to such a language feature.</li>
<li>Knowing there is no safety net of the type system encourages
developers to test (and document) more. I find this theory more compelling.</li>
<li>One can try simple modifications without the need to make many
fiddly changes, such as, for example, adding an exception to a method
signature, often in many places.</li>
</ol>
<p>I suspect, that if there are significant benefits to using a dynamically
typed language, then it is a combination of 2 and 3, or some other reason.</p>
<p>For the third, a rebuttal often mentions automatic refactoring tools.
Which may well in theory be something of a good rebuttal, but in practice developers simply
don't use such tools often. I'm not sure why not, I myself have never
taken to them. So perhaps there is a productivity gain from using a
dynamically typed language which <em>would</em> be all but negated if only
the developers would use automatic refactoring tools, but they don't.
So it <em>shouldn't</em> be a productivity win for dynamically typed
languages, but in practice it is (this is all still conjecture).</p>
<p>The second one has some evidence from psychology. There is a lot of
evidence to suggest that safety mechanisms often do not increase
overall safety but simply allow more risky behaviour. A very famous
example is a seat-belt study done in Germany. Wherein mandating the
wearing of seat-belts caused drivers to drive faster. This means that
you are more likely to have a crash, but less likely to be seriously
injured in one. This has similarly been done with anti-lock braking
systems, where the brakes being significantly better did not reduce
accidents but rather increased risky driving so that the number of
accidents remained largely constant.</p>
<p>I mentioned documentation because it's an important one. There are
plenty of libraries for statically typed languages for which the only
documentation for many of the functions/methods is the type signature.
This is often seen as "good enough", or at least good enough to mean
that API documentation is not at the top of the todo stack.
A dynamically-typed language does not typically have signatures for
methods/functions. As a result, they tend to have fewer undocumented
libraries, simply because the developer of the library knows that
their methods will otherwise not be used. If that is the case, what is
the point in the library? So they tend to write <em>something</em>, and once
you are writing <em>something</em> it isn't so hard to write something
useful.</p>
<h2>Summary</h2>
<p>This is getting too long. So I'll stop there for now. The main points are:</p>
<ol>
<li>Dynamically typed languages have had a lot of success this
century, which remains largely unexplained</li>
<li>I think that with comprehensive testing, the gains from a static
type system are diluted significantly</li>
<li>It might be that dynamically typed language encourage more/better
testing (or have some other non-obvious advantage)</li>
<li>Otherwise, there is scant evidence for anything a dynamically
typed language actually does <em>better</em>
</li>
<li>I think an obvious win for statically typed languages would be to
make the type checking phase optional.</li>
</ol>
<p>I am not sure why we do not really see any examples of languages
that have optional static type checking. In other words languages in which
the user decided when type checking should be done.</p>
<p>As a final point. For dynamically typed languages, it is common to
deploy some form of static analyser. Often these static analysers fall short of
the kind of guarantees afforded by a static type system, but they have
two significant advantages. Firstly, you can run the program without
running the static analyser. In particular, you can run your test
suite, which may well give you more information about the correctness
of your code than a type checker would. Especially in the case that
the type checker fails. It tells you about one specific problem in
your code, but not how the rest of your code does or does not pass
your tests. Secondly you can deploy different static analysers for
different problems. For example a statically typed language has to
decide whether or not to include exceptions in types. A dynamically
typed language can easily offer both. I suppose a statically typed
language <em>could</em> offer both as well.</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/selenium-and-javascript-events/" class="u-url">Selenium and Javascript Events</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/selenium-and-javascript-events/" rel="bookmark"><time class="published dt-published" datetime="2016-03-16T18:02:32Z" title="2016-03-16 18:02">2016-03-16 18:02</time></a></p>
                <p class="commentline">
        
    <a href="posts/selenium-and-javascript-events/#disqus_thread" data-disqus-identifier="cache/posts/selenium-and-javascript-events.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<p>Selenium is a great way to test web applications and it has Python bindings.
I explained in a <a href="posts/flask-%2B-coverage-analysis">previous post</a> how to
set this up with coverage analysis.</p>
<p>However, writing tests is non-trivial, in particular it is easy enough to write
tests that suffer from race conditions. Suppose you write a test that includes
a check for the existence of a particular DOM element. Here is a convenient method
to make doing so a one-liner. It assumes that you are within a class that has
the web driver as a member and that you're using 'pytest' but you can easily
adapt this for your own needs.</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">assertCssSelectorExists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">css_selector</span><span class="p">):</span>
    <span class="sd">""" Asserts that there is an element that matches the given</span>
<span class="sd">    css selector."""</span>
    <span class="c1"># We do not actually need to do anything special here, if the</span>
    <span class="c1"># element does not exist we fill fail with a NoSuchElementException</span>
    <span class="c1"># however we wrap this up in a pytest.fail because the error message</span>
    <span class="c1"># is then a bit nicer to read.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="n">css_selector</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NoSuchElementException</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">"Element {0} not found!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">css_selector</span><span class="p">))</span>
</pre>


<p>The problem is that this test might fail if it is performed too early. If you
are merely testing after loading a page, this should work, however you may be
testing after some click by a user which invokes a Javascript method.</p>
<p>Suppose you have an application which loads a page, and then loads all comments
made on that page (perhaps it is a blog engine). Now suppose you wish to allow
re-loading the list of comments without re-loading the entire page. You might
have an Ajax call.</p>
<p>As before I tend to write my Javascript in Coffeescript, so suppose I have a
Coffeescript function which is called when the user clicks on a
<code>#refresh-comment-feed-button</code> button:</p>
<pre class="code literal-block"><span></span><span class="nv">refresh_comments = </span><span class="nf">(page_id) -&gt;</span>
  <span class="nv">posting = </span><span class="nx">$</span><span class="p">.</span><span class="nx">post</span> <span class="s">'/grabcomments'</span><span class="p">,</span> <span class="nv">page_id: </span><span class="nx">page_id</span>
  <span class="nx">posting</span><span class="p">.</span><span class="nx">done</span> <span class="nx">receive_comments</span>
  <span class="nx">posting</span><span class="p">.</span><span class="nx">fail</span> <span class="nf">(data) -&gt;</span>
    <span class="p">...</span>
</pre>


<p>So this makes an Ajax call which will call the function <code>receive_comments</code>
when the Ajax call returns (successfully). We write the <code>receive_comments</code> as:</p>
<pre class="code literal-block"><span></span><span class="nv">receive_comments = </span><span class="nf">(data) -&gt;</span>
  <span class="p">...</span> <span class="nx">code</span> <span class="nx">to</span> <span class="k">delete</span> <span class="nx">current</span> <span class="nx">comments</span> <span class="o">and</span> <span class="nx">replace</span> <span class="nx">them</span> <span class="nx">with</span> <span class="nx">those</span> <span class="nx">returned</span>
</pre>


<p>Typically <code>data</code> will be some JSON data, perhaps the comments associated with
the <code>page_id</code> we gave as an argument to our Ajax call.</p>
<p>To test this you would navigate to the page in question and check
that there are no comments, then open a new browser window and make two
comments (or alternatively directly adding the comments to the database),
followed by switching back to the first browser window and then
performing the following steps:</p>
<pre class="code literal-block"><span></span>    <span class="n">refresh_comment_feed_css</span> <span class="o">=</span> <span class="s1">'#refresh-comment-feed-button'</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">click_element_with_css</span><span class="p">(</span><span class="n">refresh_comment_feed_css</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">check_comments</span><span class="p">([</span><span class="n">first_comment</span><span class="p">,</span> <span class="n">second_comment</span><span class="p">])</span>
</pre>


<p>Where <code>self.check_comments</code> is a method that checks the particular comments
exist on the current page. This could be done by using
<code>find_elements_by_css_selector</code> and then looking at the <code>text</code> attributes of
each returned element.</p>
<p>The problem is, that the final line is likely to be run before the results of
the Ajax call invoked from the click on the <code>#refresh-comment-feed-button</code> are
returned to the page.</p>
<p>A quick trick to get around this is to simply change the Javascript to somehow
record when the Ajax results are returned and then use Selenium to wait until
the relevant Javascript evaluates to true.</p>
<p>So we change our <code>receive_comments</code> method to be:</p>
<pre class="code literal-block"><span></span><span class="nv">comments_successfully_updated = </span><span class="mi">0</span>
<span class="nv">receive_comments = </span><span class="nf">(data) -&gt;</span>
  <span class="p">...</span> <span class="nx">code</span> <span class="nx">to</span> <span class="k">delete</span> <span class="nx">current</span> <span class="nx">comments</span> <span class="o">and</span> <span class="nx">replace</span> <span class="nx">them</span> <span class="nx">with</span> <span class="nx">those</span> <span class="nx">returned</span>
  <span class="nx">comments_successfully_updated</span> <span class="o">+=</span> <span class="mi">1</span>
</pre>


<p>Note that we only increment the counter after we have updated the page.</p>
<p>Now, we can update our Selenium test to be:</p>
<pre class="code literal-block"><span></span>    <span class="n">refresh_comment_feed_css</span> <span class="o">=</span> <span class="s1">'#refresh-comment-feed-button'</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">click_element_with_css</span><span class="p">(</span><span class="n">refresh_comment_feed_css</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_comment_refresh_count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">check_comments</span><span class="p">([</span><span class="n">first_comment</span><span class="p">,</span> <span class="n">second_comment</span><span class="p">])</span>
</pre>


<p>The <code>1</code> argument assumes that this will be the first time the comments are
updated during your test. Of course as you run down your test you can increase
this argument as required. The code for the <code>wait_for_comment_refresh_count</code>
is given by:</p>
<pre class="code literal-block"><span></span><span class="kn">from</span> <span class="nn">selenium.webdriver.support.ui</span> <span class="kn">import</span> <span class="n">WebDriverWait</span>
<span class="kn">from</span> <span class="nn">selenium.webdriver.support</span> <span class="kn">import</span> <span class="n">expected_conditions</span>
<span class="kn">from</span> <span class="nn">selenium.webdriver.common.by</span> <span class="kn">import</span> <span class="n">By</span>
<span class="o">...</span>

<span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span> <span class="c1"># assume that 'self.driver' is set appropriately.</span>
    <span class="k">def</span> <span class="nf">wait_for_comment_refresh_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">check_refresh_count</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
            <span class="n">script</span> <span class="o">=</span> <span class="s1">'return comments_successfully_updated;'</span>
            <span class="n">feed_count</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">execute_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">feed_count</span> <span class="o">==</span> <span class="n">count</span>
        <span class="n">WebDriverWait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">check_refresh_count</span><span class="p">)</span>
</pre>


<p>The key point is executing the Javascript to check the
<code>comments_successfully_updated</code> variable with <code>driver.execute_script</code>.
We then use a <code>WebDriverWait</code> to wait for a maximum of 5 seconds until the
our condition is satisfied.</p>
<h3>Conclusion</h3>
<p>Updating a Javascript counter to record when Javascript events have occurred
can allow your Selenium tests to synchronise, that is, wait for the correct time
to check the results of a Javascript event.</p>
<p>This can solve problems of getting a <code>StaleElementReferenceException</code> or a
<code>NoSuchElementException</code> because your Selenium test is running a check on an
element too early before your page has been updated.</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/method-cascading/" class="u-url">Method Cascading</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/method-cascading/" rel="bookmark"><time class="published dt-published" datetime="2016-02-23T14:54:35Z" title="2016-02-23 14:54">2016-02-23 14:54</time></a></p>
                <p class="commentline">
        
    <a href="posts/method-cascading/#disqus_thread" data-disqus-identifier="cache/posts/method-cascading.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Method Cascading</h2>
<p>Vasudev Ram has a thoughful <a href="http://jugad2.blogspot.co.uk/2016/02/examples-of-method-chaining-in-python.html">post about method chaining/cascading</a>
that I picked up from <a href="http://planetpython.org/">planet python</a> in which he
basically argues for the use of method cascading. I'm going to disagree.
Essentially, I simply don't understand any benefit of using cascading. It's a
nice post though and includes some references to other method cascading links.</p>
<p>Method chaining is the writing of multiple method calls directly after one
another, usually on the same line, such as (to take Vasudev's example):</p>
<pre class="code literal-block"><span></span>foo.bar().baz()
</pre>


<p>Cascading is the specific case of chaining in which each intermediate object
is the same object. To achieve this <code>bar</code> must return <code>self</code> (in Python, or
<code>this</code> in other object oriented languages).</p>
<p>Here is Vasudev's first example:</p>
<blockquote>
<p>Let's say we have a class Foo that contains two methods, bar and baz.
We create an instance of the class Foo:</p>
<pre class="code literal-block"><span></span>foo = Foo()
</pre>


<p>Without method chaining, to call both bar and baz in turn, on the object foo, we would do this:</p>
<pre class="code literal-block"><span></span># Fragment 1
foo.bar() # Call method bar() on object foo.
foo.baz() # Call method baz() on object foo.
</pre>


<p>With method chaining, we can this:</p>
<pre class="code literal-block"><span></span># Fragment 2
# Chain calls to methods bar() and baz() on object foo.
foo.bar().baz()
</pre>


</blockquote>
<p>So the claim for method cascading then is:</p>
<blockquote>
<p>One advantage of method chaining is that it reduces the number of times you
have to use the name of the object: only once in Fragment 2 above, vs. twice
in Fragment 1; and this difference will increase when there are more method
calls on the same object. Thereby, it also slightly reduces the amount of code
one has to read, understand, test, debug and maintain, overall.
Not major benefits, but can be useful.</p>
</blockquote>
<p>So method cascading reduces the number of times you have to use the name of an
object, but this makes it inherently less explicit that you're operating on the
same object. Looking at <code>foo.bar().baz()</code> does not tell me that <code>baz</code> is being
called on the same object as <code>bar</code>. Unless you're keen on method cascading and
use it yourself, it looks like the opposite.</p>
<p>Method cascading may therefore reduce</p>
<blockquote>
<p>the amount of code one has to read, understand, test, debug and maintain, overall.</p>
</blockquote>
<p>However it does so, only in a "code-golf" way. There is no point in reducing
the amount of code to understand if by doing so you increase the difficulty with
which you can understand it.</p>
<p>A common example of method cascading is one Vasudev includes, that of string
processing. Here we have a line such as (which I've translated into Python 3):</p>
<pre class="code literal-block"><span></span>print ('After uppercase then capitalize:',
        sp.dup().uppercase().capitalize().rep())
</pre>


<p>Whilst it is quite nice to be able to do this in one line without using a new
variable name, I would write this without method cascading as:</p>
<pre class="code literal-block"><span></span>duplicate = sp.dup()
duplicate.uppercase()
duplicate.capitalize()
print('After uppercase then capitalize:', duplicate.rep())
</pre>


<p>Now it is obvious that <code>dup</code> returns something new, in this case it is a
duplicate of the original string. It is also clear that <code>uppercase</code> and
<code>capitalize</code> do <em>not</em> return new objects but modify the <code>duplicate</code> object.</p>
<p>So, I'm afraid I just don't see the use case for cascading.</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/test-first-mutation-testing/" class="u-url">Test First and Mutation Testing</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/test-first-mutation-testing/" rel="bookmark"><time class="published dt-published" datetime="2016-02-19T10:14:43Z" title="2016-02-19 10:14">2016-02-19 10:14</time></a></p>
                <p class="commentline">
        
    <a href="posts/test-first-mutation-testing/#disqus_thread" data-disqus-identifier="cache/posts/test-first-mutation-testing.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Test First and Mutation Testing</h2>
<p>I'm going to argue that mutation testing has a strong use in a test first
development environment and I'll conclude by proposing a mechanism to link
mutation testing to the source code control mechanism to further aid test first
development.</p>
<h3>Test First</h3>
<p>Just to be clear, when I say 'test first' I mean development in which before
writing a feature, or fixing a bug, you first write a test which should only
pass once you have completed that feature. For the purposes of this post you
needn't be doing that for every line of code you write. The idea here applies
whether you are writing the odd feature by first writing a test for it, or
whether you have a strict policy of writing no code until there is a test for
it.</p>
<h3>Mutation Testing</h3>
<p>Mutation testing is the process of automatically changing some parts of your
source code generally to check that your test suite is not indifferent to the
change. For example, your source code may contain a conditional statement
such as the following:</p>
<pre class="code literal-block"><span></span>    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">do_something</span><span class="p">()</span>
</pre>


<p>Now if we suppose that the current condition is correct, then changing it to
a similar but different condition, for example <code>x &gt;= 0</code> or <code>x &gt; 1</code> then
presumably this would turn correct code into incorrect code. If your tests are
comprehensive then at least one of them should fail due to the now incorrect
code.</p>
<h3>Fail First</h3>
<p>It's easy enough to unintentionally write a test that always passes, or perhaps
passes too easily. One of the reasons for writing the test first is to make sure
that it fails when the feature has not yet been implemented (or fixed). However,
often such a test can fail for trivial reasons. For example you may write a unit
test that fails simple because the method it tests is not yet defined. Similarly
a web test may fail because the route is not yet defined. Unless you continue to
run the test during development of your feature you won't necessarily know that
your test is particularly effective at catching when your feature is broken.</p>
<h3>Fail After</h3>
<p>Whether you write the test before your new feature or after the feature is
ready, mutation testing can assist with the problem of non-stringent tests.
Mutation testing can assist in reassuring you that your new test is effective at
catching errors, whether those errors are introduced when the feature is
developed or through later changes. If you apply lots of mutations to your code
and your new test never fails then there is a strong likelihood that you have an
ineffective test that passes too easily.</p>
<h3>Source Code control</h3>
<p>A feature I would like to add to a mutation test package is to integrate with
a source code control mechanism such as Git. The mutation tester must choose
lines of the program to mutate. However, your new test is presumably aimed at
testing the new code that you write. Hence we could use the source code control
mechanism to mutate lines of code that are newer than the test or some specified
commit. That way we would focus our mutation testing to testing the efficacy of
the new test(s) with respect to the new or changed lines of code.</p>
<p>This does not preclude doing general mutation testing for features that, for
example, depend upon a lot of existing code. Perhaps your new feature is simply
a display of existing calculations.</p>
<h3>Conclusion</h3>
<p>In summary:</p>
<ul>
<li>Mutation testing helps find tests that are ineffective.</li>
<li>This plays particularly well with a test first development process in which
    the test often fails the first time for trivial reasons, thus giving you
    false assurance that your test can fail.</li>
<li>Integrating source code control to target the mutations towards new code
    could improve this significantly, or at least make it a bit more convenient.</li>
</ul>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/import-placement/" class="u-url">Placement of Python Import Statements</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/import-placement/" rel="bookmark"><time class="published dt-published" datetime="2016-02-03T13:08:54Z" title="2016-02-03 13:08">2016-02-03 13:08</time></a></p>
                <p class="commentline">
        
    <a href="posts/import-placement/#disqus_thread" data-disqus-identifier="cache/posts/import-placement.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<p><a href="https://www.python.org/dev/peps/pep-0008/#imports">Pep 8 specifies</a>
that all import statements should be "put at the top of the file, just after any
module comments and docstrings, and before module globals and constants."
However, it does not really specify the logic behind this. I'm going to try to
articulate some reasons to have import statements somewhere other than directly
at the top of the file. I'll also state some arguments for having such
<code>import</code> statements at the top.</p>
<p>Note, that
<a href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds">Pep 8 also specifies</a>
that it is important to "know when to be inconsistent -- sometimes the style guide just doesn't
apply. When in doubt, use your best judgment". So the purpose of this post is to
suggest some reasons why you might deviate from the style guide with respect to
<code>import</code> statements at the top.</p>
<p class="more"><a href="posts/import-placement/">Read more…</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/update-flask%2Bcoverage/" class="u-url">Update: Flask+Coverage</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/update-flask%2Bcoverage/" rel="bookmark"><time class="published dt-published" datetime="2016-01-26T14:59:44Z" title="2016-01-26 14:59">2016-01-26 14:59</time></a></p>
                <p class="commentline">
        
    <a href="posts/update-flask%2Bcoverage/#disqus_thread" data-disqus-identifier="cache/posts/update-flask+coverage.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Update: Flask+Coverage Analysis</h2>
<p>In a <a href="posts/flask-%2B-coverage-analysis">previous post</a>
I demonstrated how to get <code>coverage</code> analysis working for a Flask web application
in a relatively simple manner. In the section <em>"At then end of your tests"</em> I
stated that you needed your tests to clean-up by telling the server to shutdown.
The end of your test code would look something like this:</p>
<pre class="code literal-block"><span></span><span class="k">finally</span><span class="p">:</span>
    <span class="n">driver</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">get_url</span><span class="p">(</span><span class="s1">'shutdown'</span><span class="p">))</span>
    <span class="o">...</span>
</pre>


<p>This could have made things a little fiddly since your test code would have to
make sure to access the <code>shutdown</code> route exactly once, regardless of how many
tests were run.</p>
<p>However, I realised that we could remove the burden from the test code by
simply doing this in <code>manage.py</code> file.</p>
<h3>Updated <code>manage.py</code>
</h3>
<p>Previously, we had the following code within our <code>manage.py</code> script within the
<code>run_with_test_server</code> method:</p>
<pre class="code literal-block"><span></span><span class="n">test_process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">test_command</span><span class="p">)</span>
<span class="n">test_process</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">server_return_code</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre>


<p>We now update this to be:</p>
<pre class="code literal-block"><span></span><span class="n">test_process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">test_command</span><span class="p">)</span>
<span class="n">test_process</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">'TEST_SERVER_PORT'</span><span class="p">]</span>
<span class="n">shutdown_url</span> <span class="o">=</span> <span class="s1">'http://localhost:{}/shutdown'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">shutdown_url</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
<span class="n">server_return_code</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre>


<p>Doing so means you can just write your tests without any need to worry about
shutting down the server.
The <a href="https://github.com/allanderek/flask-coverage-example">example repository</a>
has been appropriately updated.</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/flask-%2B-coverage-analysis/" class="u-url">Flask + Coverage Analysis</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/flask-%2B-coverage-analysis/" rel="bookmark"><time class="published dt-published" datetime="2016-01-25T15:20:50Z" title="2016-01-25 15:20">2016-01-25 15:20</time></a></p>
                <p class="commentline">
        
    <a href="posts/flask-%2B-coverage-analysis/#disqus_thread" data-disqus-identifier="cache/posts/flask-+-coverage-analysis.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Flask + Coverage Analysis</h2>
<p>This post demonstrates a simple web application written in Flask with coverage
analysis for the tests. The main idea should be pretty translatable into most
Python web application frameworks.</p>
<h4>Update</h4>
<p>I've updated this scheme and described the update <a href="posts/update-flask%2Bcoverage">here</a>.</p>
<h3>tl;dr</h3>
<p>If you're having difficulty getting coverage analysis to work with Flask then
have a look at my <a href="https://github.com/allanderek/flask-coverage-example">example repository</a>.
The main take away is that you simply start the server in a process of its own
using <code>coverage</code> to start it. However, in order for this to work you have to
make sure you can shut the server process down from the test process. To do this
we simply add a new "shutdown" route which is only available under testing. Your
test code, whether written in Python or, say Javascript, can then make a request
to this "shutdown" route once it completes its tests. This allows the server
process to shutdown naturally and therefore allow 'coverage' to complete.</p>
<h3>Introduction</h3>
<p>It's a good idea to test the web applications you author. Most web application
frameworks provide relatively solid means to do this. However, if you're doing
browser automated functional tests against a live server I've found that getting
<a href="https://pypi.python.org/pypi/coverage">coverage</a> to work to be non-trivial. A quick search will reveal similar
difficulties such as <a href="http://stackoverflow.com/questions/23745370/setting-up-coverage-py-with-flask">this</a>
stack overflow question, which ultimately points to the <a href="http://coverage.readthedocs.org/en/latest/subprocess.html">coverage documentation
on sub-processes</a>.</p>
<p>Part of the reason for this might be that the Flask-Testing extension provides
live server testing class that starts your server in testing mode as part of
the start-up of the test. It then also shuts the server process down, but in
so doing does not allow coverage to complete.</p>
<p>A simpler method is to start the server process yourself under coverage. You
then only need a means to shutdown the server programatically. I do this by
adding a <code>shutdown</code> route.</p>
<p class="more"><a href="posts/flask-%2B-coverage-analysis/">Read more…</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/selenium-and-casper/" class="u-url">Selenium vs CasperJS</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/selenium-and-casper/" rel="bookmark"><time class="published dt-published" datetime="2016-01-08T11:11:40Z" title="2016-01-08 11:11">2016-01-08 11:11</time></a></p>
                <p class="commentline">
        
    <a href="posts/selenium-and-casper/#disqus_thread" data-disqus-identifier="cache/posts/selenium-and-casper.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<p>Suppose you have a web service using a Python web framework such as Flask.
So you wish to do a full user test by automating the browser. Should you use
the Python bindings to Selenium or CasperJS? In this post I wish to detail some
of the advantages and drawbacks of both.</p>
<h3>Python + Selenium Setup</h3>
<p>This is fairly straightforward. You are simply writing some Python code that
happens to call a library which binds to Selenium. In order for this to work
you will need to install phantomJS but using <code>npm</code> this is pretty trivial.</p>
<h3>Javascript + CasperJS Setup</h3>
<p>I say Javascript, but at least when I'm using casperJS it tends to be from
Coffeescript, but whichever is your fancy works well enough. Similarly to the
above you will need to install casperJS through the <code>npm</code> but again this is
pretty trivial.</p>
<h3>Speed</h3>
<p>For my sample project the casperJS tests are faster, by quite a bit. This
certainly warrants some more investigation as to exactly why this is the case,
but for now my sample project runs the casperJS tests in around 3 seconds whilst
the Selenium ones take around 12 seconds to do the same amount of work. I'm not
sure whether this is a constant factor or whether it will get worse with more
tests.</p>
<p class="more"><a href="posts/selenium-and-casper/">Read more…</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/welcome/" class="u-url">Welcome</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Allan Clark
            </span></p>
            <p class="dateline"><a href="posts/welcome/" rel="bookmark"><time class="published dt-published" datetime="2016-01-06T16:48:42Z" title="2016-01-06 16:48">2016-01-06 16:48</time></a></p>
                <p class="commentline">
        
    <a href="posts/welcome/#disqus_thread" data-disqus-identifier="cache/posts/Welcome.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <div>
<h2>Welcome to Coding Diet</h2>
<p>This is a simple blog intended to be related to good software development
practices, but will probably contain more practical examples that I come across
as I code. I use mainly Python for programming but, since a proportion of the
coding I do is for web development I end up writing CoffeeScript or vanilla
Javascript as well. I'm not averse to other languages as well and have a fairly
strong background in Haskell which I may occasionally refer to as an example.</p>
</div>
    </div>
    </article>
</div>



        
       <script>var disqus_shortname="allanderek";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2016         <a href="mailto:allan.clark@gmail.com">Allan Clark</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
