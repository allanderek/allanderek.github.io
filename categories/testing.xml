<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Coding Diet (testing)</title><link>http://allanderek.github.io/</link><description></description><atom:link href="http://allanderek.github.io/categories/testing.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 17 Mar 2016 11:25:26 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Selenium and Javascript Events</title><link>http://allanderek.github.io/posts/selenium-and-javascript-events/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Selenium is a great way to test web applications and it has Python bindings.
I explained in a &lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;previous post&lt;/a&gt; how to
set this up with coverage analysis.&lt;/p&gt;
&lt;p&gt;However, writing tests is non-trivial, in particular it is easy enough to write
tests that suffer from race conditions. Suppose you write a test that includes
a check for the existence of a particular DOM element. Here is a convenient method
to make doing so a one-liner. It assumes that you are within a class that has
the web driver as a member and that you're using 'pytest' but you can easily
adapt this for your own needs.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assertCssSelectorExists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;""" Asserts that there is an element that matches the given&lt;/span&gt;
&lt;span class="sd"&gt;    css selector."""&lt;/span&gt;
    &lt;span class="c1"&gt;# We do not actually need to do anything special here, if the&lt;/span&gt;
    &lt;span class="c1"&gt;# element does not exist we fill fail with a NoSuchElementException&lt;/span&gt;
    &lt;span class="c1"&gt;# however we wrap this up in a pytest.fail because the error message&lt;/span&gt;
    &lt;span class="c1"&gt;# is then a bit nicer to read.&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_css_selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Element {0} not found!"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The problem is that this test might fail if it is performed too early. If you
are merely testing after loading a page, this should work, however you may be
testing after some click by a user which invokes a Javascript method.&lt;/p&gt;
&lt;p&gt;Suppose you have an application which loads a page, and then loads all comments
made on that page (perhaps it is a blog engine). Now suppose you wish to allow
re-loading the list of comments without re-loading the entire page. You might
have an Ajax call.&lt;/p&gt;
&lt;p&gt;As before I tend to write my Javascript in Coffeescript, so suppose I have a
Coffeescript function which is called when the user clicks on a
&lt;code&gt;#refresh-comment-feed-button&lt;/code&gt; button:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;refresh_comments = &lt;/span&gt;&lt;span class="nf"&gt;(page_id) -&amp;gt;&lt;/span&gt;
  &lt;span class="nv"&gt;posting = &lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;post&lt;/span&gt; &lt;span class="s"&gt;'/grabcomments'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;page_id: &lt;/span&gt;&lt;span class="nx"&gt;page_id&lt;/span&gt;
  &lt;span class="nx"&gt;posting&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;done&lt;/span&gt; &lt;span class="nx"&gt;receive_comments&lt;/span&gt;
  &lt;span class="nx"&gt;posting&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fail&lt;/span&gt; &lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So this makes an Ajax call which will call the function &lt;code&gt;receive_comments&lt;/code&gt;
when the Ajax call returns (successfully). We write the &lt;code&gt;receive_comments&lt;/code&gt; as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;receive_comments = &lt;/span&gt;&lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;code&lt;/span&gt; &lt;span class="nx"&gt;to&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nx"&gt;comments&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="nx"&gt;replace&lt;/span&gt; &lt;span class="nx"&gt;them&lt;/span&gt; &lt;span class="nx"&gt;with&lt;/span&gt; &lt;span class="nx"&gt;those&lt;/span&gt; &lt;span class="nx"&gt;returned&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Typically &lt;code&gt;data&lt;/code&gt; will be some JSON data, perhaps the comments associated with
the &lt;code&gt;page_id&lt;/code&gt; we gave as an argument to our Ajax call.&lt;/p&gt;
&lt;p&gt;To test this you would navigate to the page in question and check
that there are no comments, then open a new browser window and make two
comments (or alternatively directly adding the comments to the database),
followed by switching back to the first browser window and then
performing the following steps:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'#refresh-comment-feed-button'&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click_element_with_css&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_comments&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;first_comment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_comment&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Where &lt;code&gt;self.check_comments&lt;/code&gt; is a method that checks the particular comments
exist on the current page. This could be done by using
&lt;code&gt;find_elements_by_css_selector&lt;/code&gt; and then looking at the &lt;code&gt;text&lt;/code&gt; attributes of
each returned element.&lt;/p&gt;
&lt;p&gt;The problem is, that the final line is likely to be run before the results of
the Ajax call invoked from the click on the &lt;code&gt;#refresh-comment-feed-button&lt;/code&gt; are
returned to the page.&lt;/p&gt;
&lt;p&gt;A quick trick to get around this is to simply change the Javascript to somehow
record when the Ajax results are returned and then use Selenium to wait until
the relevant Javascript evaluates to true.&lt;/p&gt;
&lt;p&gt;So we change our &lt;code&gt;receive_comments&lt;/code&gt; method to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;comments_successfully_updated = &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;receive_comments = &lt;/span&gt;&lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;code&lt;/span&gt; &lt;span class="nx"&gt;to&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nx"&gt;comments&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="nx"&gt;replace&lt;/span&gt; &lt;span class="nx"&gt;them&lt;/span&gt; &lt;span class="nx"&gt;with&lt;/span&gt; &lt;span class="nx"&gt;those&lt;/span&gt; &lt;span class="nx"&gt;returned&lt;/span&gt;
  &lt;span class="nx"&gt;comments_successfully_updated&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Note that we only increment the counter after we have updated the page.&lt;/p&gt;
&lt;p&gt;Now, we can update our Selenium test to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'#refresh-comment-feed-button'&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click_element_with_css&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait_for_comment_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_comments&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;first_comment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_comment&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;1&lt;/code&gt; argument assumes that this will be the first time the comments are
updated during your test. Of course as you run down your test you can increase
this argument as required. The code for the &lt;code&gt;wait_for_comment_refresh_count&lt;/code&gt;
is given by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;expected_conditions&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;By&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# assume that 'self.driver' is set appropriately.&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wait_for_comment_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;script&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'return comments_successfully_updated;'&lt;/span&gt;
            &lt;span class="n"&gt;feed_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_script&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;script&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;feed_count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
        &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check_refresh_count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The key point is executing the Javascript to check the
&lt;code&gt;comments_successfully_updated&lt;/code&gt; variable with &lt;code&gt;driver.execute_script&lt;/code&gt;.
We then use a &lt;code&gt;WebDriverWait&lt;/code&gt; to wait for a maximum of 5 seconds until the
our condition is satisfied.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Updating a Javascript counter to record when Javascript events have occurred
can allow your Selenium tests to synchronise, that is, wait for the correct time
to check the results of a Javascript event.&lt;/p&gt;
&lt;p&gt;This can solve problems of getting a &lt;code&gt;StaleElementReferenceException&lt;/code&gt; or a
&lt;code&gt;NoSuchElementException&lt;/code&gt; because your Selenium test is running a check on an
element too early before your page has been updated.&lt;/p&gt;&lt;/div&gt;</description><category>python</category><category>selenium</category><category>testing</category><guid>http://allanderek.github.io/posts/selenium-and-javascript-events/</guid><pubDate>Wed, 16 Mar 2016 18:02:32 GMT</pubDate></item><item><title>Test First and Mutation Testing</title><link>http://allanderek.github.io/posts/test-first-mutation-testing/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Test First and Mutation Testing&lt;/h2&gt;
&lt;p&gt;I'm going to argue that mutation testing has a strong use in a test first
development environment and I'll conclude by proposing a mechanism to link
mutation testing to the source code control mechanism to further aid test first
development.&lt;/p&gt;
&lt;h3&gt;Test First&lt;/h3&gt;
&lt;p&gt;Just to be clear, when I say 'test first' I mean development in which before
writing a feature, or fixing a bug, you first write a test which should only
pass once you have completed that feature. For the purposes of this post you
needn't be doing that for every line of code you write. The idea here applies
whether you are writing the odd feature by first writing a test for it, or
whether you have a strict policy of writing no code until there is a test for
it.&lt;/p&gt;
&lt;h3&gt;Mutation Testing&lt;/h3&gt;
&lt;p&gt;Mutation testing is the process of automatically changing some parts of your
source code generally to check that your test suite is not indifferent to the
change. For example, your source code may contain a conditional statement
such as the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now if we suppose that the current condition is correct, then changing it to
a similar but different condition, for example &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; or &lt;code&gt;x &amp;gt; 1&lt;/code&gt; then
presumably this would turn correct code into incorrect code. If your tests are
comprehensive then at least one of them should fail due to the now incorrect
code.&lt;/p&gt;
&lt;h3&gt;Fail First&lt;/h3&gt;
&lt;p&gt;It's easy enough to unintentionally write a test that always passes, or perhaps
passes too easily. One of the reasons for writing the test first is to make sure
that it fails when the feature has not yet been implemented (or fixed). However,
often such a test can fail for trivial reasons. For example you may write a unit
test that fails simple because the method it tests is not yet defined. Similarly
a web test may fail because the route is not yet defined. Unless you continue to
run the test during development of your feature you won't necessarily know that
your test is particularly effective at catching when your feature is broken.&lt;/p&gt;
&lt;h3&gt;Fail After&lt;/h3&gt;
&lt;p&gt;Whether you write the test before your new feature or after the feature is
ready, mutation testing can assist with the problem of non-stringent tests.
Mutation testing can assist in reassuring you that your new test is effective at
catching errors, whether those errors are introduced when the feature is
developed or through later changes. If you apply lots of mutations to your code
and your new test never fails then there is a strong likelihood that you have an
ineffective test that passes too easily.&lt;/p&gt;
&lt;h3&gt;Source Code control&lt;/h3&gt;
&lt;p&gt;A feature I would like to add to a mutation test package is to integrate with
a source code control mechanism such as Git. The mutation tester must choose
lines of the program to mutate. However, your new test is presumably aimed at
testing the new code that you write. Hence we could use the source code control
mechanism to mutate lines of code that are newer than the test or some specified
commit. That way we would focus our mutation testing to testing the efficacy of
the new test(s) with respect to the new or changed lines of code.&lt;/p&gt;
&lt;p&gt;This does not preclude doing general mutation testing for features that, for
example, depend upon a lot of existing code. Perhaps your new feature is simply
a display of existing calculations.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mutation testing helps find tests that are ineffective.&lt;/li&gt;
&lt;li&gt;This plays particularly well with a test first development process in which
    the test often fails the first time for trivial reasons, thus giving you
    false assurance that your test can fail.&lt;/li&gt;
&lt;li&gt;Integrating source code control to target the mutations towards new code
    could improve this significantly, or at least make it a bit more convenient.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>mutation testing</category><category>python</category><category>scc</category><category>testing</category><guid>http://allanderek.github.io/posts/test-first-mutation-testing/</guid><pubDate>Fri, 19 Feb 2016 10:14:43 GMT</pubDate></item><item><title>Update: Flask+Coverage</title><link>http://allanderek.github.io/posts/update-flask%2Bcoverage/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Update: Flask+Coverage Analysis&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;previous post&lt;/a&gt;
I demonstrated how to get &lt;code&gt;coverage&lt;/code&gt; analysis working for a Flask web application
in a relatively simple manner. In the section &lt;em&gt;"At then end of your tests"&lt;/em&gt; I
stated that you needed your tests to clean-up by telling the server to shutdown.
The end of your test code would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shutdown'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This could have made things a little fiddly since your test code would have to
make sure to access the &lt;code&gt;shutdown&lt;/code&gt; route exactly once, regardless of how many
tests were run.&lt;/p&gt;
&lt;p&gt;However, I realised that we could remove the burden from the test code by
simply doing this in &lt;code&gt;manage.py&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Updated &lt;code&gt;manage.py&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Previously, we had the following code within our &lt;code&gt;manage.py&lt;/code&gt; script within the
&lt;code&gt;run_with_test_server&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We now update this to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'TEST_SERVER_PORT'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;shutdown_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'http://localhost:{}/shutdown'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shutdown_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bytes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Doing so means you can just write your tests without any need to worry about
shutting down the server.
The &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;
has been appropriately updated.&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>python</category><category>selenium</category><category>testing</category><guid>http://allanderek.github.io/posts/update-flask%2Bcoverage/</guid><pubDate>Tue, 26 Jan 2016 14:59:44 GMT</pubDate></item><item><title>Flask + Coverage Analysis</title><link>http://allanderek.github.io/posts/flask-%2B-coverage-analysis/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Flask + Coverage Analysis&lt;/h2&gt;
&lt;p&gt;This post demonstrates a simple web application written in Flask with coverage
analysis for the tests. The main idea should be pretty translatable into most
Python web application frameworks.&lt;/p&gt;
&lt;h4&gt;Update&lt;/h4&gt;
&lt;p&gt;I've updated this scheme and described the update &lt;a href="http://allanderek.github.io/posts/update-flask%2Bcoverage"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;tl;dr&lt;/h3&gt;
&lt;p&gt;If you're having difficulty getting coverage analysis to work with Flask then
have a look at my &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;.
The main take away is that you simply start the server in a process of its own
using &lt;code&gt;coverage&lt;/code&gt; to start it. However, in order for this to work you have to
make sure you can shut the server process down from the test process. To do this
we simply add a new "shutdown" route which is only available under testing. Your
test code, whether written in Python or, say Javascript, can then make a request
to this "shutdown" route once it completes its tests. This allows the server
process to shutdown naturally and therefore allow 'coverage' to complete.&lt;/p&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;It's a good idea to test the web applications you author. Most web application
frameworks provide relatively solid means to do this. However, if you're doing
browser automated functional tests against a live server I've found that getting
&lt;a href="https://pypi.python.org/pypi/coverage"&gt;coverage&lt;/a&gt; to work to be non-trivial. A quick search will reveal similar
difficulties such as &lt;a href="http://stackoverflow.com/questions/23745370/setting-up-coverage-py-with-flask"&gt;this&lt;/a&gt;
stack overflow question, which ultimately points to the &lt;a href="http://coverage.readthedocs.org/en/latest/subprocess.html"&gt;coverage documentation
on sub-processes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Part of the reason for this might be that the Flask-Testing extension provides
live server testing class that starts your server in testing mode as part of
the start-up of the test. It then also shuts the server process down, but in
so doing does not allow coverage to complete.&lt;/p&gt;
&lt;p&gt;A simpler method is to start the server process yourself under coverage. You
then only need a means to shutdown the server programatically. I do this by
adding a &lt;code&gt;shutdown&lt;/code&gt; route.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>python</category><category>selenium</category><category>testing</category><guid>http://allanderek.github.io/posts/flask-%2B-coverage-analysis/</guid><pubDate>Mon, 25 Jan 2016 15:20:50 GMT</pubDate></item><item><title>Selenium vs CasperJS</title><link>http://allanderek.github.io/posts/selenium-and-casper/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Suppose you have a web service using a Python web framework such as Flask.
So you wish to do a full user test by automating the browser. Should you use
the Python bindings to Selenium or CasperJS? In this post I wish to detail some
of the advantages and drawbacks of both.&lt;/p&gt;
&lt;h3&gt;Python + Selenium Setup&lt;/h3&gt;
&lt;p&gt;This is fairly straightforward. You are simply writing some Python code that
happens to call a library which binds to Selenium. In order for this to work
you will need to install phantomJS but using &lt;code&gt;npm&lt;/code&gt; this is pretty trivial.&lt;/p&gt;
&lt;h3&gt;Javascript + CasperJS Setup&lt;/h3&gt;
&lt;p&gt;I say Javascript, but at least when I'm using casperJS it tends to be from
Coffeescript, but whichever is your fancy works well enough. Similarly to the
above you will need to install casperJS through the &lt;code&gt;npm&lt;/code&gt; but again this is
pretty trivial.&lt;/p&gt;
&lt;h3&gt;Speed&lt;/h3&gt;
&lt;p&gt;For my sample project the casperJS tests are faster, by quite a bit. This
certainly warrants some more investigation as to exactly why this is the case,
but for now my sample project runs the casperJS tests in around 3 seconds whilst
the Selenium ones take around 12 seconds to do the same amount of work. I'm not
sure whether this is a constant factor or whether it will get worse with more
tests.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://allanderek.github.io/posts/selenium-and-casper/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>casperjs</category><category>python</category><category>selenium</category><category>testing</category><guid>http://allanderek.github.io/posts/selenium-and-casper/</guid><pubDate>Fri, 08 Jan 2016 11:11:40 GMT</pubDate></item></channel></rss>