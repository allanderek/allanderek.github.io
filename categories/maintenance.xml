<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Coding Diet (maintenance)</title><link>https://allanderek.github.io/</link><description></description><atom:link type="application/rss+xml" rel="self" href="https://allanderek.github.io/categories/maintenance.xml"></atom:link><language>en</language><lastBuildDate>Sat, 14 Jan 2017 15:12:50 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Lazy calculation</title><link>https://allanderek.github.io/posts/lazy-calculation/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;In many cases whilst programming there is a decision to be made as to whether
to &lt;em&gt;store&lt;/em&gt; some state, or (re)&lt;em&gt;caluate&lt;/em&gt; it as and when needed. Obviously every
situation is different and therefore there is no one answer which fits. In this
post I'm going to attempt to explain the distinction and the benefits/drawbacks
of either approach. I hope that just remembering that this choice exists will
force me to make an explicit choice, such that I may think about it a bit more.&lt;/p&gt;
&lt;h2&gt;Distinction&lt;/h2&gt;
&lt;p&gt;The distinction is a little akin to that between eager evaluation and lazy
evalution but it is not the same. The distinction here is about code-maintenance.
I'll start with a very simple example, and then move to a more realistic example
which involves access to a database, which makes the decision a bit more interesting.&lt;/p&gt;
&lt;p&gt;Suppose you have a very simple &lt;code&gt;class&lt;/code&gt; representing a person and the children
that they may have:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;):
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;gender&lt;/span&gt;):
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;gender&lt;/span&gt; = &lt;span class="n"&gt;gender&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt; = []
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt; = []

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_girl&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;)
        &lt;span class="n"&gt;girl&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'female'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;girl&lt;/span&gt;)
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;girl&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_boy&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="n"&gt;boy&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'male'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;boy&lt;/span&gt;)
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;boy&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now, suppose somewhere in your code you wish to return the number of children
that a particular person has. You can either keep track of this, or calculate it
on the fly, here is the keep-track-of-it version:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;):
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;gender&lt;/span&gt;):
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;gender&lt;/span&gt; = &lt;span class="n"&gt;gender&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt; = []
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt; = []
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;number_of_children&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_girl&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;)
        &lt;span class="n"&gt;girl&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'female'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;girl&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;number_of_children&lt;/span&gt; += &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;girl&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_boy&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="n"&gt;boy&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'boy'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;boy&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;number_of_children&lt;/span&gt; += &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;boy&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here is a possible calculate-it-on-the-fly version:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;):
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;gender&lt;/span&gt;):
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;gender&lt;/span&gt; = &lt;span class="n"&gt;gender&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt; = []
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt; = []

    &lt;span class="nv"&gt;@property&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;number_of_children&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt;) + &lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt;)

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_girl&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;)
        &lt;span class="n"&gt;girl&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'female'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;girls&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;girl&lt;/span&gt;)
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;girl&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;have_baby_boy&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="n"&gt;boy&lt;/span&gt; = &lt;span class="n"&gt;Person&lt;/span&gt;(&lt;span class="s"&gt;'boy'&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;boys&lt;/span&gt;.&lt;span class="n"&gt;append&lt;/span&gt;(&lt;span class="n"&gt;boy&lt;/span&gt;)
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;boy&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In this particular case I prefer the calculate-it-on-the-fly approach. I like
that I did not have to modify any existing code, I only had to add some. If I
add some other method (suppose an &lt;code&gt;adopt&lt;/code&gt; method) then in the keep-track-of-it
version I have to make sure I update our state variable &lt;code&gt;number_of_children&lt;/code&gt;
appropriately. Finally, if we change our definition of what a 'child' is,
suppose they have to be under 18 years-of-age, then keeping track-of-it, might
not work at all, or if it does I have to be very careful about updating parents
whenever a child ages.&lt;/p&gt;
&lt;p&gt;In terms of performance, this is often trickty to evaluate correctly. Essentially,
you're asking whether the calculation of the state on the fly, is more expensive,
than code to keep track of it. This of course depends hugely on often you inspect
the state. You may do a lot of work to keep-track of a state variable that is
never inspected, or inspected only very rarely. On the other hand, if it is
inspected often, but not updated much, the calculate-it-on-the-fly approach,
may be needlessly re-doing the exact same computation many times.&lt;/p&gt;
&lt;p&gt;As a side-note there is a &lt;a href="https://pypi.python.org/pypi/lazy/1.2"&gt;lazy&lt;/a&gt; package
for Python that lets you calculate attributes once when needed, and then stores
the result for later retrieval. Of course if you update anything the calculation
depends upon you have to make sure an invalidate the stored result. I've found
it is useful in the case that an attribute won't ever need to be re-calculated,
but might never need to be calculated at all (and is expensive to do so).&lt;/p&gt;
&lt;h2&gt;More interesting example&lt;/h2&gt;
&lt;p&gt;For in-memory occurrences such as the simple example above, often the choice is
pretty clear. Code is often clearer if you calculate-it-on-the-fly, and only
resort to keep-track-of-it whenever the value is somewhat expensive to calculate,
used very often, or particularly simple to keep track of.&lt;/p&gt;
&lt;p&gt;However, the choice becomes more interesting when the calculation of the value
involves some external state, even if keeping-track-of-it is done on the
external state. A common case is when the state is kept in a database. In Python,
you may well be using an ORM to access the external state. &lt;/p&gt;
&lt;p&gt;Consider an online game website, for some game that has four players. Let's
suppose the game is turn-based and players are not expected to be logged in for
the entire duration, but just take their turn whenever they are online. The game
then can be in multiple states: waiting for players, running, finished. So in
some ORM you might describe a game like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Game&lt;/span&gt;(&lt;span class="n"&gt;database&lt;/span&gt;.&lt;span class="n"&gt;Model&lt;/span&gt;):
    &lt;span class="n"&gt;player_one_id&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Integer&lt;/span&gt;, &lt;span class="n"&gt;ForeignKey&lt;/span&gt;(&lt;span class="s"&gt;'user.id'&lt;/span&gt;))
    &lt;span class="n"&gt;player_two_id&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Integer&lt;/span&gt;, &lt;span class="n"&gt;ForeignKey&lt;/span&gt;(&lt;span class="s"&gt;'user.id'&lt;/span&gt;))
    &lt;span class="n"&gt;player_three_id&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Integer&lt;/span&gt;, &lt;span class="n"&gt;ForeignKey&lt;/span&gt;(&lt;span class="s"&gt;'user.id'&lt;/span&gt;))
    &lt;span class="n"&gt;player_four_id&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Integer&lt;/span&gt;, &lt;span class="n"&gt;ForeignKey&lt;/span&gt;(&lt;span class="s"&gt;'user.id'&lt;/span&gt;))

    &lt;span class="n"&gt;winner_id&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Integer&lt;/span&gt;, &lt;span class="n"&gt;ForeignKey&lt;/span&gt;(&lt;span class="s"&gt;'user.id'&lt;/span&gt;))

    .... &lt;span class="n"&gt;bunch&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;actually&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;game&lt;/span&gt; &lt;span class="k"&gt;state&lt;/span&gt; ....
&lt;/pre&gt;


&lt;p&gt;Now, suppose you wish to display a list of running games for a user, you could
do it something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Game&lt;/span&gt;(&lt;span class="n"&gt;database&lt;/span&gt;.&lt;span class="n"&gt;Model&lt;/span&gt;):
    ... &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="o"&gt;before&lt;/span&gt; ...
    &lt;span class="n"&gt;state_names&lt;/span&gt; = [&lt;span class="s"&gt;'waiting'&lt;/span&gt;, &lt;span class="s"&gt;'running'&lt;/span&gt;, &lt;span class="s"&gt;'finished'&lt;/span&gt;]
    &lt;span class="k"&gt;state&lt;/span&gt; = &lt;span class="n"&gt;Column&lt;/span&gt;(&lt;span class="n"&gt;Enum&lt;/span&gt;(*&lt;span class="n"&gt;state_names&lt;/span&gt;), &lt;span class="n"&gt;nullable&lt;/span&gt;=&lt;span class="nb"&gt;False&lt;/span&gt;, &lt;span class="k"&gt;default&lt;/span&gt;=&lt;span class="s"&gt;'waiting'&lt;/span&gt;)

    &lt;span class="nv"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;running_games&lt;/span&gt;(&lt;span class="n"&gt;user&lt;/span&gt;):
        &lt;span class="n"&gt;games&lt;/span&gt; = &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;query&lt;/span&gt;.&lt;span class="n"&gt;filter&lt;/span&gt;(
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="k"&gt;state&lt;/span&gt; == &lt;span class="s"&gt;'running'&lt;/span&gt;,
            &lt;span class="n"&gt;or_&lt;/span&gt;(
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
            )
        ).&lt;span class="nb"&gt;all&lt;/span&gt;()
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;games&lt;/span&gt;

    &lt;span class="nv"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;open_games&lt;/span&gt;(&lt;span class="n"&gt;user&lt;/span&gt;):
        &lt;span class="n"&gt;games&lt;/span&gt; = &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;query&lt;/span&gt;.&lt;span class="n"&gt;filter&lt;/span&gt;(
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="k"&gt;state&lt;/span&gt; == &lt;span class="s"&gt;'waiting'&lt;/span&gt;,
            &lt;span class="n"&gt;and_&lt;/span&gt;(
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
            )
        ).&lt;span class="nb"&gt;all&lt;/span&gt;()
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;games&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Using this way you would have to make sure that when the fourth player joins a
game the state is set to 'running', and when the game finishes the state is set
to 'finished', along with the 'winner' being set.&lt;/p&gt;
&lt;p&gt;Instead one could use calculate-it-on-the-fly as in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Game&lt;/span&gt;(&lt;span class="n"&gt;database&lt;/span&gt;.&lt;span class="n"&gt;Model&lt;/span&gt;):
    ... &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="o"&gt;before&lt;/span&gt; ...
    &lt;span class="c c-Singleline"&gt;# No state column&lt;/span&gt;

    &lt;span class="nv"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;running_games&lt;/span&gt;(&lt;span class="n"&gt;user&lt;/span&gt;):
        &lt;span class="n"&gt;games&lt;/span&gt; = &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;query&lt;/span&gt;.&lt;span class="n"&gt;filter&lt;/span&gt;(
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; != &lt;span class="n"&gt;None&lt;/span&gt;,
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; != &lt;span class="n"&gt;None&lt;/span&gt;,
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; != &lt;span class="n"&gt;None&lt;/span&gt;,
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; != &lt;span class="n"&gt;None&lt;/span&gt;,
            &lt;span class="n"&gt;or_&lt;/span&gt;(
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; == &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
            ),
            &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;winner_id&lt;/span&gt; == &lt;span class="n"&gt;None&lt;/span&gt;
        ).&lt;span class="nb"&gt;all&lt;/span&gt;()
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;games&lt;/span&gt;

    &lt;span class="nv"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;open_games&lt;/span&gt;(&lt;span class="n"&gt;user&lt;/span&gt;):
        &lt;span class="n"&gt;games&lt;/span&gt; = &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;query&lt;/span&gt;.&lt;span class="n"&gt;filter&lt;/span&gt;(
            &lt;span class="n"&gt;or_&lt;/span&gt;(
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; == &lt;span class="n"&gt;None&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; == &lt;span class="n"&gt;None&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; == &lt;span class="n"&gt;None&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; == &lt;span class="n"&gt;None&lt;/span&gt;,
            )
            &lt;span class="n"&gt;and_&lt;/span&gt;(
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_one_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_two_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_three_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
                &lt;span class="n"&gt;Game&lt;/span&gt;.&lt;span class="n"&gt;player_four_id&lt;/span&gt; != &lt;span class="n"&gt;user&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;,
            )
        ).&lt;span class="nb"&gt;all&lt;/span&gt;()
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;games&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This could be simplified a bit if we assume that players fill slots in order
such that it is never the case that &lt;code&gt;Game.player_four_id&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; whilst
one of the others is. &lt;/p&gt;
&lt;p&gt;In this particular case then I think the keep-track-of-it is a little simpler.
But this hugely depends on the logic for joining a game, taking ones turn, and
finishing the game. In particular when a game is finished you have to set the
&lt;code&gt;winner_id&lt;/code&gt; column anyway, so it seems like not too much of a burden to
additionally set the &lt;code&gt;state&lt;/code&gt; column.&lt;/p&gt;
&lt;p&gt;However, there are many situations in which, calculate-it-on-the-fly is more
appropriate. A common case, occurs when the rules for state changes may change.
For example, in the game case, we may decide that as long as there are two
players, people can play the game, which is therefore &lt;code&gt;running&lt;/code&gt;. People may
join a &lt;code&gt;running&lt;/code&gt; game, provided it is not full, and may leave a &lt;code&gt;running&lt;/code&gt; game.
In this case, calculate-it-on-the-fly simply updates the rules for when a game
is &lt;code&gt;running&lt;/code&gt;. However, keep-track-of-it, not only has to update its rules for
when to modify a state (including now reverting a game from &lt;code&gt;running&lt;/code&gt; to
&lt;code&gt;waiting&lt;/code&gt; when someone leaves a two player game), but must also go through the
database and modify the &lt;code&gt;state&lt;/code&gt; column of any existing games. To do this, the
database update code will essentially have to mimic the &lt;code&gt;calculate-it-on-the-fly&lt;/code&gt;
code anyway.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;There is often a choice to be made between maintaining some kind of state up-front,
and calculating it whenever it is required. Both are useful and should be used
depending on the situation. Recalling that there is such a choice may help a
programmer to explicitly make that choice, and perhaps even record the reasons
for it.&lt;/p&gt;&lt;/div&gt;</description><category>maintenance</category><category>python</category><guid>https://allanderek.github.io/posts/lazy-calculation/</guid><pubDate>Wed, 11 Jan 2017 17:47:02 GMT</pubDate></item><item><title>Covering dead code</title><link>https://allanderek.github.io/posts/covering-dead-code/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Dougal Matthews has written a &lt;a href="http://www.dougalmatthews.com/2016/Dec/16/finding-dead-code-with-vulture/"&gt;blog post&lt;/a&gt;
detailing how &lt;a href="https://pypi.python.org/pypi/vulture"&gt;Vulture&lt;/a&gt; can be used to find some dead code.
For me this was an important reminder not to rely on &lt;a href="https://pypi.python.org/pypi/coverage/"&gt;coverage analysis&lt;/a&gt;
to detect dead code and remove it from the your maintenance burden. More generally, whilst I adore
automated analysis tools that assist the developer in maintaining their code,
such automated analysis can give a false sense of completeness, or lead to the
developer believing that their code is "good enough". It is not a problem I have
any solution for though. The rest of the post will try to illuminate this view
point through the example of dead-code removal.&lt;/p&gt;
&lt;p&gt;Dead code seems like something that should be automatically detected by tools such as both Vulture and coverage.py and
indeed many instances of dead code &lt;em&gt;are&lt;/em&gt; automatically detected by such tools. However it is
worth remembering that there are instances of dead code which can never be automatically detected.&lt;/p&gt;
&lt;p&gt;As a brief reminder, dead code is code that we should delete. We should delete it generally
because it either has no way of being invoked, or because we no longer require its functionality.
Because the former category has a more or less formal definition much of it can (at least in theory)
be detected automatically. The latter category is often more difficult to detect because there
are no hard rules for it. For example, you may have some code to log the state of a particular object,
and this code &lt;strong&gt;is&lt;/strong&gt; invoked by production code. However, the reason for logging
the state of a particular object is no longer required. Pretty much no automated analysis can
detect this because simply writing down the rules for when such code is dead is at best non-trivial.&lt;/p&gt;
&lt;p&gt;Here are some example categories of dead code along with how we might detect/track such dead code.&lt;/p&gt;
&lt;h3&gt;Unused Variables&lt;/h3&gt;
&lt;p&gt;If you define a variable, but then never use it, the definition is likely dead-code.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def my_function():
    x = assigned-expr
    # some code that never uses x
&lt;/pre&gt;


&lt;p&gt;Unless the right-hand side of the definition (&lt;code&gt;assigned-expr&lt;/code&gt;) has some side-effect
which is important then the assignment is dead-code and should be removed. Note here
that coverage analysis would tell you that the line is being executed.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;As noted coverage analysis won't work here, and you would have to use something
like Vulture. Many decent IDEs will also warn you about most such circumstances.&lt;/p&gt;
&lt;h3&gt;Unused Methods/Class definitions&lt;/h3&gt;
&lt;p&gt;If you simple define a method or class which you never then invoke. The exception
here is if you're developing a library or otherwise exposing an interface. In this
case you should have some automated tests which should invoke the method/class.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;Can generally be done by coverage analysis. There are however some tricky situations
which were described in the above mentioned
&lt;a href="http://www.dougalmatthews.com/2016/Dec/16/finding-dead-code-with-vulture/"&gt;blog post&lt;/a&gt;.
Essentially you may add a unit-test to test a particular method, which later becomes
unused by the actual application but is still invoked by the unit test.&lt;/p&gt;
&lt;h3&gt;Unused Counters&lt;/h3&gt;
&lt;p&gt;At one point, you may have decided to keep a count of some particular occurrence,
such as the number of guesses. Perhaps at one stage you displayed the number of
guesses remaining, but later decided to make the number of guesses unlimited.
You may end up with code that looks something like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;guesses = 0
def make_guess():
    guess = get_input()
    global guesses
    guesses += 1
    return guess
&lt;/pre&gt;


&lt;p&gt;Originally your &lt;code&gt;get_input&lt;/code&gt; looked something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;total_guesses = 20
def get_input():
    remaining = total_guesses - guesses
    return input('You have {} guesses remaining:'.format(remaining))
&lt;/pre&gt;


&lt;p&gt;But since you decided to give unlimited guesses you got rid of that and it is
now simply:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def get_input():
    return input("Please input a guess:")
&lt;/pre&gt;


&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;Slightly more tricky this one since the variable &lt;code&gt;guesses&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; inspected,
it is inspected in the update &lt;code&gt;guesses += 1&lt;/code&gt;. Still you could make ask that your
automated tool ignore such uses and, in this case, still report the variable as
being defined but not used (perhaps Vulture allows this, I don't know).&lt;/p&gt;
&lt;p&gt;However, it is not hard to come up with similar examples in which some value is
maintained but never actually used. For example we might have written something
like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;if total_guesses - guesses &amp;gt; 0:
    guesses += 1
&lt;/pre&gt;


&lt;p&gt;Which would likely fool most automated analyses.&lt;/p&gt;
&lt;p&gt;Of course I've called this category "Counters", but it refers to maintaining any
kind of state that you don't utlimately make use of. You may have originally kept
a list/set of guesses made so far so as to prevent someone making the same guess
more than once. If you later decided against this you might forget to remove
the code which updates the set of guesses that have been made.&lt;/p&gt;
&lt;h3&gt;Unused Web Application Routes&lt;/h3&gt;
&lt;p&gt;You may have a route in your web application which is never linked to by any
part of the rest of your application.
Using &lt;a href="https://pypi.python.org/pypi/Flask/0.12"&gt;Flask&lt;/a&gt;, for this example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;@route('/misc/contact', methods=['GET'])
def contact_page():
    """Display a contact us page"""
    return flask.render_template('contact.jinja')
&lt;/pre&gt;


&lt;p&gt;Now, if, in the rest of your application, you never link to this page, then the
page is not likely to be discovered by a user. You may even have a different
contact page, perhaps called "support" or "feedback". Perhaps this new contact
page was built to replace the older one which it has done, but you left the code for
the old route available.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;This is tricky. First of all, you may perfectly well have a page which is not
linked to within the remainder of your application but you do want to have
available. For example you may have a route (or routes) for an API used by your
associated mobile application. &lt;/p&gt;
&lt;p&gt;If you have some tests you can use coverage analysis, but if you are doing that
you likely originally had some test which covered this page, even if that unit
test only visited the page and checked that it contained some content, for example
you may have had:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def test_contact_page(self):
    rv = self.app.get('/misc/contact')
    assert b'id="contact-form"' in rv.data
&lt;/pre&gt;


&lt;p&gt;If this test still runs, then your dead route will still be covered by your tests.
Checking whether or not the method is ever referenced directly will not work because
either such a test will not pick up the unused method because it is used within
the &lt;code&gt;@route&lt;/code&gt; decorator call, or such a test would ignore that but then flag &lt;em&gt;all&lt;/em&gt;
your routes as unused.&lt;/p&gt;
&lt;p&gt;The only relatively robust way would be to check for calls to
&lt;code&gt;flask.url_for("test_contact_page")&lt;/code&gt;. Such a check would have to look in templates
as well. It may &lt;em&gt;still&lt;/em&gt; fail because such a call might never actually be invoked.
So the test would have to check the coverage analysis as well.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I take it for granted that checking for (and removing) dead code is a useful
activity that improves your code quality and removes some of your technical debt
burden. In other words, I take it for granted that dead code represents a form
of technical debt. With that in mind it seems useful to deploy any automated
analyses which can do part of the job for you. However, any code analysis
tool (whether static or dynamic) that cannot detect &lt;strong&gt;all&lt;/strong&gt; (of a class of)
problems, has the disadvantage that it will tend to foster a false sense of completeness.&lt;/p&gt;
&lt;p&gt;The hope is that doing the automatable part automatically frees the developer up
to do the non-automatable parts. In practice I've found that there is a tendency
to move the goal-posts from "remove all dead-code" to "remove all dead-code that
the automated analysis complains about". More generally from "maintain code free
from problem X" to "maintain code such that the automated tools do not complain about
problem X".&lt;/p&gt;
&lt;p&gt;I'm certainly not arguing not to use such automated analyses. However I don't have
a solution for the problem of this implicit and accidental moving (or rather widening)
of the goal posts.&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>dead code</category><category>maintenance</category><category>python</category><guid>https://allanderek.github.io/posts/covering-dead-code/</guid><pubDate>Tue, 03 Jan 2017 12:04:24 GMT</pubDate></item></channel></rss>