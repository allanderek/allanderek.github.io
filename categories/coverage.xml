<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coding Diet (coverage)</title><link>https://allanderek.github.io/</link><description></description><atom:link rel="self" href="https://allanderek.github.io/categories/coverage.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 21 Feb 2017 09:57:14 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Flask and Pytest coverage</title><link>https://allanderek.github.io/posts/flask-and-pytest-coverage/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;I have written before about Flask and obtaining test coverage results
&lt;a href="https://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;here&lt;/a&gt;
and with an update
&lt;a href="https://allanderek.github.io/posts/update-flask%2Bcoverage"&gt;here&lt;/a&gt;.
This is pretty trivial if you're writing unit tests that directly call the application, but if you actually want to write tests which animate a browser, for example with selenium, then it's a little more complicated, because the browser/test code has to run concurrently with the server code.&lt;/p&gt;
&lt;p&gt;Previously I would have the Flask server run in a separate process and run 'coverage' over that process. This was slightly unsatisfying, partly because you sometimes want coverage analysis of your actual tests. Test suites, just like application code, can grow in size with many utility functions and imports etc. which may eventually end up not actually being used. So it is good to know that you're not needlessly maintaining some test code which is not actually invoked.&lt;/p&gt;
&lt;p&gt;We could probably get around this restriction by running coverage in both the server process and the test-runner's process and combine the results (or simply view them separately). However, this was unsatisfying simply because it felt like something that should not be necessary. Today I spent a bit of time setting up the scheme to test a Flask application without the need for a separate process.&lt;/p&gt;
&lt;p&gt;I solved this now, by not using Flask's included Werkzeug server and instead using the WSGI server included in the standard-library &lt;code&gt;wsgiref.simple_server&lt;/code&gt; module. Here is, a minimal example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Configuration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;TEST_SERVER_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5001&lt;/span&gt;

&lt;span class="n"&gt;application&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flask&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_object&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Configuration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="nd"&gt;@application.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;frontpage&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt; &lt;span class="c1"&gt;# Should not be covered&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;'I am the lizard queen!'&lt;/span&gt; &lt;span class="c1"&gt;# Should be in coverage.&lt;/span&gt;



&lt;span class="c1"&gt;# Now for some testing.&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.action_chains&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ActionChains&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;
&lt;span class="c1"&gt;# Currently just used for the temporary hack to quit the phantomjs process&lt;/span&gt;
&lt;span class="c1"&gt;# see below in quit_driver.&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;signal&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wsgiref.simple_server&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ServerThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'TESTING'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'TEST_SERVER_PORT'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;httpd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wsgiref&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;simple_server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'localhost'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;httpd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serve_forever&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;httpd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shutdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BrowserClient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""Interacts with a running instance of the application via animating a&lt;/span&gt;
&lt;span class="sd"&gt;    browser."""&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;browser&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"phantom"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;driver_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="s1"&gt;'phantom'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PhantomJS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s1"&gt;'chrome'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Chrome&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s1"&gt;'firefox'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;browser&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_window_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;760&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;finalise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="c1"&gt;# A bit of hack this but currently there is some bug I believe in&lt;/span&gt;
        &lt;span class="c1"&gt;# the phantomjs code rather than selenium, but in any case it means that&lt;/span&gt;
        &lt;span class="c1"&gt;# the phantomjs process is not being killed so we do so explicitly here&lt;/span&gt;
        &lt;span class="c1"&gt;# for the time being. Obviously we can remove this when that bug is&lt;/span&gt;
        &lt;span class="c1"&gt;# fixed. See: https://github.com/SeleniumHQ/selenium/issues/767&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log_current_page&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output_basename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;page_source&lt;/span&gt;
        &lt;span class="c1"&gt;# This is frequently what we really care about so I also output it&lt;/span&gt;
        &lt;span class="c1"&gt;# here as well to make it convenient to inspect (with highlighting).&lt;/span&gt;
        &lt;span class="n"&gt;basename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;output_basename&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s1"&gt;'log-current-page'&lt;/span&gt;
        &lt;span class="n"&gt;file_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;basename&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;'.html'&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'w'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;outfile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;outfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;!-- {} --&amp;gt; "&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="n"&gt;outfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;basename&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;'.png'&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save_screenshot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;make_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;endpoint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;app_context&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;flask&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url_for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;endpoint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# TODO: Ultimately we'll need a fixture so that we can have multiple&lt;/span&gt;
&lt;span class="c1"&gt;# test functions that all use the same server thread and possibly the same&lt;/span&gt;
&lt;span class="c1"&gt;# browser client.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_server&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;server_thread&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ServerThread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;server_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;server_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BrowserClient&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'TEST_SERVER_PORT'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'SERVER_NAME'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'localhost:{}'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'frontpage'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="s1"&gt;'I am the lizard queen!'&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;page_source&lt;/span&gt;

    &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;finalise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;server_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;server_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;To run this you will of course need &lt;code&gt;flask&lt;/code&gt; as well as &lt;code&gt;pytest&lt;/code&gt;, &lt;code&gt;pytest-cov&lt;/code&gt;, and &lt;code&gt;selenium&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ pip install flask pytest pytest-cov selenium
&lt;/pre&gt;


&lt;p&gt;In addition you will need the &lt;code&gt;phantomjs&lt;/code&gt; to run:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ npm install phantomjs
$ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:./node_modules/.bin/
&lt;/pre&gt;


&lt;p&gt;Then to run it, the command is:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ py.test --cov&lt;span class="o"&gt;=&lt;/span&gt;./ app.py
$ coverage html
&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;coverage html&lt;/code&gt; is of course optional and only if you wish to view the results in friendly HTML format.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;I've not used this extensively myself yet, so there may be some problems when using a more interesting flask application.&lt;/p&gt;
&lt;p&gt;Don't put your virtual environment directory in the same directory as &lt;code&gt;app.py&lt;/code&gt; because in that case it will perform coverage analysis over the standard library and dependencies.&lt;/p&gt;
&lt;p&gt;In a real application you will probably want to make a &lt;code&gt;pytest&lt;/code&gt; fixture out of the server thread and browser client. So that you can use each for multiple separate test functions. Essentially your test function should just be the part inside the &lt;code&gt;try&lt;/code&gt; clause.&lt;/p&gt;
&lt;p&gt;I have not used the &lt;code&gt;log_current_page&lt;/code&gt; method but I frequently find it quite useful so included it here nonetheless.&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>flask</category><category>python</category><category>tests</category><guid>https://allanderek.github.io/posts/flask-and-pytest-coverage/</guid><pubDate>Mon, 20 Feb 2017 16:27:27 GMT</pubDate></item><item><title>Covering dead code</title><link>https://allanderek.github.io/posts/covering-dead-code/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Dougal Matthews has written a &lt;a href="http://www.dougalmatthews.com/2016/Dec/16/finding-dead-code-with-vulture/"&gt;blog post&lt;/a&gt;
detailing how &lt;a href="https://pypi.python.org/pypi/vulture"&gt;Vulture&lt;/a&gt; can be used to find some dead code.
For me this was an important reminder not to rely on &lt;a href="https://pypi.python.org/pypi/coverage/"&gt;coverage analysis&lt;/a&gt;
to detect dead code and remove it from the your maintenance burden. More generally, whilst I adore
automated analysis tools that assist the developer in maintaining their code,
such automated analysis can give a false sense of completeness, or lead to the
developer believing that their code is "good enough". It is not a problem I have
any solution for though. The rest of the post will try to illuminate this view
point through the example of dead-code removal.&lt;/p&gt;
&lt;p&gt;Dead code seems like something that should be automatically detected by tools such as both Vulture and coverage.py and
indeed many instances of dead code &lt;em&gt;are&lt;/em&gt; automatically detected by such tools. However it is
worth remembering that there are instances of dead code which can never be automatically detected.&lt;/p&gt;
&lt;p&gt;As a brief reminder, dead code is code that we should delete. We should delete it generally
because it either has no way of being invoked, or because we no longer require its functionality.
Because the former category has a more or less formal definition much of it can (at least in theory)
be detected automatically. The latter category is often more difficult to detect because there
are no hard rules for it. For example, you may have some code to log the state of a particular object,
and this code &lt;strong&gt;is&lt;/strong&gt; invoked by production code. However, the reason for logging
the state of a particular object is no longer required. Pretty much no automated analysis can
detect this because simply writing down the rules for when such code is dead is at best non-trivial.&lt;/p&gt;
&lt;p&gt;Here are some example categories of dead code along with how we might detect/track such dead code.&lt;/p&gt;
&lt;h3&gt;Unused Variables&lt;/h3&gt;
&lt;p&gt;If you define a variable, but then never use it, the definition is likely dead-code.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def my_function():
    x = assigned-expr
    # some code that never uses x
&lt;/pre&gt;


&lt;p&gt;Unless the right-hand side of the definition (&lt;code&gt;assigned-expr&lt;/code&gt;) has some side-effect
which is important then the assignment is dead-code and should be removed. Note here
that coverage analysis would tell you that the line is being executed.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;As noted coverage analysis won't work here, and you would have to use something
like Vulture. Many decent IDEs will also warn you about most such circumstances.&lt;/p&gt;
&lt;h3&gt;Unused Methods/Class definitions&lt;/h3&gt;
&lt;p&gt;If you simple define a method or class which you never then invoke. The exception
here is if you're developing a library or otherwise exposing an interface. In this
case you should have some automated tests which should invoke the method/class.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;Can generally be done by coverage analysis. There are however some tricky situations
which were described in the above mentioned
&lt;a href="http://www.dougalmatthews.com/2016/Dec/16/finding-dead-code-with-vulture/"&gt;blog post&lt;/a&gt;.
Essentially you may add a unit-test to test a particular method, which later becomes
unused by the actual application but is still invoked by the unit test.&lt;/p&gt;
&lt;h3&gt;Unused Counters&lt;/h3&gt;
&lt;p&gt;At one point, you may have decided to keep a count of some particular occurrence,
such as the number of guesses. Perhaps at one stage you displayed the number of
guesses remaining, but later decided to make the number of guesses unlimited.
You may end up with code that looks something like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;guesses = 0
def make_guess():
    guess = get_input()
    global guesses
    guesses += 1
    return guess
&lt;/pre&gt;


&lt;p&gt;Originally your &lt;code&gt;get_input&lt;/code&gt; looked something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;total_guesses = 20
def get_input():
    remaining = total_guesses - guesses
    return input('You have {} guesses remaining:'.format(remaining))
&lt;/pre&gt;


&lt;p&gt;But since you decided to give unlimited guesses you got rid of that and it is
now simply:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def get_input():
    return input("Please input a guess:")
&lt;/pre&gt;


&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;Slightly more tricky this one since the variable &lt;code&gt;guesses&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; inspected,
it is inspected in the update &lt;code&gt;guesses += 1&lt;/code&gt;. Still you could make ask that your
automated tool ignore such uses and, in this case, still report the variable as
being defined but not used (perhaps Vulture allows this, I don't know).&lt;/p&gt;
&lt;p&gt;However, it is not hard to come up with similar examples in which some value is
maintained but never actually used. For example we might have written something
like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;if total_guesses - guesses &amp;gt; 0:
    guesses += 1
&lt;/pre&gt;


&lt;p&gt;Which would likely fool most automated analyses.&lt;/p&gt;
&lt;p&gt;Of course I've called this category "Counters", but it refers to maintaining any
kind of state that you don't utlimately make use of. You may have originally kept
a list/set of guesses made so far so as to prevent someone making the same guess
more than once. If you later decided against this you might forget to remove
the code which updates the set of guesses that have been made.&lt;/p&gt;
&lt;h3&gt;Unused Web Application Routes&lt;/h3&gt;
&lt;p&gt;You may have a route in your web application which is never linked to by any
part of the rest of your application.
Using &lt;a href="https://pypi.python.org/pypi/Flask/0.12"&gt;Flask&lt;/a&gt;, for this example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;@route('/misc/contact', methods=['GET'])
def contact_page():
    """Display a contact us page"""
    return flask.render_template('contact.jinja')
&lt;/pre&gt;


&lt;p&gt;Now, if, in the rest of your application, you never link to this page, then the
page is not likely to be discovered by a user. You may even have a different
contact page, perhaps called "support" or "feedback". Perhaps this new contact
page was built to replace the older one which it has done, but you left the code for
the old route available.&lt;/p&gt;
&lt;h4&gt;Detection&lt;/h4&gt;
&lt;p&gt;This is tricky. First of all, you may perfectly well have a page which is not
linked to within the remainder of your application but you do want to have
available. For example you may have a route (or routes) for an API used by your
associated mobile application. &lt;/p&gt;
&lt;p&gt;If you have some tests you can use coverage analysis, but if you are doing that
you likely originally had some test which covered this page, even if that unit
test only visited the page and checked that it contained some content, for example
you may have had:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;def test_contact_page(self):
    rv = self.app.get('/misc/contact')
    assert b'id="contact-form"' in rv.data
&lt;/pre&gt;


&lt;p&gt;If this test still runs, then your dead route will still be covered by your tests.
Checking whether or not the method is ever referenced directly will not work because
either such a test will not pick up the unused method because it is used within
the &lt;code&gt;@route&lt;/code&gt; decorator call, or such a test would ignore that but then flag &lt;em&gt;all&lt;/em&gt;
your routes as unused.&lt;/p&gt;
&lt;p&gt;The only relatively robust way would be to check for calls to
&lt;code&gt;flask.url_for("test_contact_page")&lt;/code&gt;. Such a check would have to look in templates
as well. It may &lt;em&gt;still&lt;/em&gt; fail because such a call might never actually be invoked.
So the test would have to check the coverage analysis as well.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I take it for granted that checking for (and removing) dead code is a useful
activity that improves your code quality and removes some of your technical debt
burden. In other words, I take it for granted that dead code represents a form
of technical debt. With that in mind it seems useful to deploy any automated
analyses which can do part of the job for you. However, any code analysis
tool (whether static or dynamic) that cannot detect &lt;strong&gt;all&lt;/strong&gt; (of a class of)
problems, has the disadvantage that it will tend to foster a false sense of completeness.&lt;/p&gt;
&lt;p&gt;The hope is that doing the automatable part automatically frees the developer up
to do the non-automatable parts. In practice I've found that there is a tendency
to move the goal-posts from "remove all dead-code" to "remove all dead-code that
the automated analysis complains about". More generally from "maintain code free
from problem X" to "maintain code such that the automated tools do not complain about
problem X".&lt;/p&gt;
&lt;p&gt;I'm certainly not arguing not to use such automated analyses. However I don't have
a solution for the problem of this implicit and accidental moving (or rather widening)
of the goal posts.&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>dead code</category><category>maintenance</category><category>python</category><guid>https://allanderek.github.io/posts/covering-dead-code/</guid><pubDate>Tue, 03 Jan 2017 12:04:24 GMT</pubDate></item><item><title>Update: Flask+Coverage</title><link>https://allanderek.github.io/posts/update-flask%2Bcoverage/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Update: Flask+Coverage Analysis&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="https://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;previous post&lt;/a&gt;
I demonstrated how to get &lt;code&gt;coverage&lt;/code&gt; analysis working for a Flask web application
in a relatively simple manner. In the section &lt;em&gt;"At then end of your tests"&lt;/em&gt; I
stated that you needed your tests to clean-up by telling the server to shutdown.
The end of your test code would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shutdown'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This could have made things a little fiddly since your test code would have to
make sure to access the &lt;code&gt;shutdown&lt;/code&gt; route exactly once, regardless of how many
tests were run.&lt;/p&gt;
&lt;p&gt;However, I realised that we could remove the burden from the test code by
simply doing this in &lt;code&gt;manage.py&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Updated &lt;code&gt;manage.py&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Previously, we had the following code within our &lt;code&gt;manage.py&lt;/code&gt; script within the
&lt;code&gt;run_with_test_server&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We now update this to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'TEST_SERVER_PORT'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;shutdown_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'http://localhost:{}/shutdown'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shutdown_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bytes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Doing so means you can just write your tests without any need to worry about
shutting down the server.
The &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;
has been appropriately updated.&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>python</category><category>selenium</category><category>testing</category><guid>https://allanderek.github.io/posts/update-flask%2Bcoverage/</guid><pubDate>Tue, 26 Jan 2016 14:59:44 GMT</pubDate></item><item><title>Flask + Coverage Analysis</title><link>https://allanderek.github.io/posts/flask-%2B-coverage-analysis/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Flask + Coverage Analysis&lt;/h2&gt;
&lt;p&gt;This post demonstrates a simple web application written in Flask with coverage
analysis for the tests. The main idea should be pretty translatable into most
Python web application frameworks.&lt;/p&gt;
&lt;h4&gt;Update&lt;/h4&gt;
&lt;p&gt;I've updated this scheme and described the update &lt;a href="https://allanderek.github.io/posts/update-flask%2Bcoverage"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;tl;dr&lt;/h3&gt;
&lt;p&gt;If you're having difficulty getting coverage analysis to work with Flask then
have a look at my &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;.
The main take away is that you simply start the server in a process of its own
using &lt;code&gt;coverage&lt;/code&gt; to start it. However, in order for this to work you have to
make sure you can shut the server process down from the test process. To do this
we simply add a new "shutdown" route which is only available under testing. Your
test code, whether written in Python or, say Javascript, can then make a request
to this "shutdown" route once it completes its tests. This allows the server
process to shutdown naturally and therefore allow 'coverage' to complete.&lt;/p&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;It's a good idea to test the web applications you author. Most web application
frameworks provide relatively solid means to do this. However, if you're doing
browser automated functional tests against a live server I've found that getting
&lt;a href="https://pypi.python.org/pypi/coverage"&gt;coverage&lt;/a&gt; to work to be non-trivial. A quick search will reveal similar
difficulties such as &lt;a href="http://stackoverflow.com/questions/23745370/setting-up-coverage-py-with-flask"&gt;this&lt;/a&gt;
stack overflow question, which ultimately points to the &lt;a href="http://coverage.readthedocs.org/en/latest/subprocess.html"&gt;coverage documentation
on sub-processes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Part of the reason for this might be that the Flask-Testing extension provides
live server testing class that starts your server in testing mode as part of
the start-up of the test. It then also shuts the server process down, but in
so doing does not allow coverage to complete.&lt;/p&gt;
&lt;p&gt;A simpler method is to start the server process yourself under coverage. You
then only need a means to shutdown the server programatically. I do this by
adding a &lt;code&gt;shutdown&lt;/code&gt; route.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://allanderek.github.io/posts/flask-%2B-coverage-analysis/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>coverage</category><category>python</category><category>selenium</category><category>testing</category><guid>https://allanderek.github.io/posts/flask-%2B-coverage-analysis/</guid><pubDate>Mon, 25 Jan 2016 15:20:50 GMT</pubDate></item></channel></rss>