<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coding Diet</title><link>http://allanderek.github.io/</link><description>My quest to stop writing too much code.</description><atom:link rel="self" href="http://allanderek.github.io/rss.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 17 Mar 2016 09:41:45 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Selenium and Javascript Events</title><link>http://allanderek.github.io/posts/selenium-and-javascript-events/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Selenium is a great way to test web applications and it has Python bindings.
I explained in a &lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;previous post&lt;/a&gt; how to
set this up with coverage analysis.&lt;/p&gt;
&lt;p&gt;However, writing tests is non-trivial, in particular it is easy enough to write
tests that suffer from race conditions. Suppose you write a test that includes
a check for the existence of a particular DOM element. Here is a convenient method
to make doing so a one-liner. It assumes that you are within a class that has
the web driver as a member and that you're using 'pytest' but you can easily
adapt this for your own needs.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assertCssSelectorExists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;""" Asserts that there is an element that matches the given&lt;/span&gt;
&lt;span class="sd"&gt;    css selector."""&lt;/span&gt;
    &lt;span class="c1"&gt;# We do not actually need to do anything special here, if the&lt;/span&gt;
    &lt;span class="c1"&gt;# element does not exist we fill fail with a NoSuchElementException&lt;/span&gt;
    &lt;span class="c1"&gt;# however we wrap this up in a pytest.fail because the error message&lt;/span&gt;
    &lt;span class="c1"&gt;# is then a bit nicer to read.&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_css_selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Element {0} not found!"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The problem is that this test might fail if it is performed too early. If you
are merely testing after loading a page, this should work, however you may be
testing after some click by a user which invokes a Javascript method.&lt;/p&gt;
&lt;p&gt;Suppose you have an application which loads a page, and then loads all comments
made on that page (perhaps it is a blog engine). Now suppose you wish to allow
re-loading the list of comments without re-loading the entire page. You might
have an Ajax call.&lt;/p&gt;
&lt;p&gt;As before I tend to write my Javascript in Coffeescript, so suppose I have a
Coffeescript function which is called when the user clicks on a
&lt;code&gt;#refresh-comment-feed-button&lt;/code&gt; button:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;refresh_comments = &lt;/span&gt;&lt;span class="nf"&gt;(page_id) -&amp;gt;&lt;/span&gt;
  &lt;span class="nv"&gt;posting = &lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;post&lt;/span&gt; &lt;span class="s"&gt;'/grabcomments'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;page_id: &lt;/span&gt;&lt;span class="nx"&gt;page_id&lt;/span&gt;
  &lt;span class="nx"&gt;posting&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;done&lt;/span&gt; &lt;span class="nx"&gt;receive_comments&lt;/span&gt;
  &lt;span class="nx"&gt;posting&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fail&lt;/span&gt; &lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So this makes an Ajax call which will call the function &lt;code&gt;receive_comments&lt;/code&gt;
when the Ajax call returns (successfully). We write the &lt;code&gt;receive_comments&lt;/code&gt; as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;receive_comments = &lt;/span&gt;&lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;code&lt;/span&gt; &lt;span class="nx"&gt;to&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nx"&gt;comments&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="nx"&gt;replace&lt;/span&gt; &lt;span class="nx"&gt;them&lt;/span&gt; &lt;span class="nx"&gt;with&lt;/span&gt; &lt;span class="nx"&gt;those&lt;/span&gt; &lt;span class="nx"&gt;returned&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Typically &lt;code&gt;data&lt;/code&gt; will be some JSON data, perhaps the comments associated with
the &lt;code&gt;page_id&lt;/code&gt; we gave as an argument to our Ajax call.&lt;/p&gt;
&lt;p&gt;To test this you would navigate to the page in question and check
that there are no comments, then open a new browser window and make two
comments (or alternatively directly adding the comments to the database),
followed by switching back to the first browser window and then
performing the following steps:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'#refresh-comment-feed-button'&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click_element_with_css&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_comments&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;first_comment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_comment&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Where &lt;code&gt;self.check_comments&lt;/code&gt; is a method that checks the particular comments
exist on the current page. This could be done by using
&lt;code&gt;find_elements_by_css_selector&lt;/code&gt; and then looking at the &lt;code&gt;text&lt;/code&gt; attributes of
each returned element.&lt;/p&gt;
&lt;p&gt;The problem is, that the final line is likely to be run before the results of
the Ajax call invoked from the click on the &lt;code&gt;#refresh-comment-feed-button&lt;/code&gt; are
returned to the page.&lt;/p&gt;
&lt;p&gt;A quick trick to get around this is to simply change the Javascript to somehow
record when the Ajax results are returned and then use Selenium to wait until
the relevant Javascript evaluates to true.&lt;/p&gt;
&lt;p&gt;So we change our &lt;code&gt;receive_comments&lt;/code&gt; method to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;comments_successfully_updated = &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;receive_comments = &lt;/span&gt;&lt;span class="nf"&gt;(data) -&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;code&lt;/span&gt; &lt;span class="nx"&gt;to&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nx"&gt;comments&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="nx"&gt;replace&lt;/span&gt; &lt;span class="nx"&gt;them&lt;/span&gt; &lt;span class="nx"&gt;with&lt;/span&gt; &lt;span class="nx"&gt;those&lt;/span&gt; &lt;span class="nx"&gt;returned&lt;/span&gt;
  &lt;span class="nx"&gt;comments_successfully_updated&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Note that we only increment the counter after we have updated the page.&lt;/p&gt;
&lt;p&gt;Now, we can update our Selenium test to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'#refresh-comment-feed-button'&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click_element_with_css&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;refresh_comment_feed_css&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait_for_comment_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_comments&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;first_comment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_comment&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;1&lt;/code&gt; argument assumes that this will be the first time the comments are
updated during your test. Of course as you run down your test you can increase
this argument as required. The code for the &lt;code&gt;wait_for_comment_refresh_count&lt;/code&gt;
is given by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;expected_conditions&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;By&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# assume that 'self.driver' is set appropriately.&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wait_for_comment_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_refresh_count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;script&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'return comments_successfully_updated;'&lt;/span&gt;
            &lt;span class="n"&gt;feed_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_script&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;script&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;feed_count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
        &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check_refresh_count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The key point is executing the Javascript to check the
&lt;code&gt;comments_successfully_updated&lt;/code&gt; variable with &lt;code&gt;driver.execute_script&lt;/code&gt;.
We then use a &lt;code&gt;WebDriverWait&lt;/code&gt; to wait for a maximum of 5 seconds until the
our condition is satisfied.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Updating a Javascript counter to record when Javascript events have occurred
can allow your Selenium tests to synchronise, that is, wait for the correct time
to check the results of a Javascript event.&lt;/p&gt;
&lt;p&gt;This can solve problems of getting a &lt;code&gt;StaleElementReferenceException&lt;/code&gt; or a
&lt;code&gt;NoSuchElementException&lt;/code&gt; because your Selenium test is running a check on an
element too early before your page has been updated.&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/selenium-and-javascript-events/</guid><pubDate>Wed, 16 Mar 2016 18:02:32 GMT</pubDate></item><item><title>Method Cascading</title><link>http://allanderek.github.io/posts/method-cascading/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Method Cascading&lt;/h2&gt;
&lt;p&gt;Vasudev Ram has a thoughful &lt;a href="http://jugad2.blogspot.co.uk/2016/02/examples-of-method-chaining-in-python.html"&gt;post about method chaining/cascading&lt;/a&gt;
that I picked up from &lt;a href="http://planetpython.org/"&gt;planet python&lt;/a&gt; in which he
basically argues for the use of method cascading. I'm going to disagree.
Essentially, I simply don't understand any benefit of using cascading. It's a
nice post though and includes some references to other method cascading links.&lt;/p&gt;
&lt;p&gt;Method chaining is the writing of multiple method calls directly after one
another, usually on the same line, such as (to take Vasudev's example):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;foo.bar().baz()
&lt;/pre&gt;


&lt;p&gt;Cascading is the specific case of chaining in which each intermediate object
is the same object. To achieve this &lt;code&gt;bar&lt;/code&gt; must return &lt;code&gt;self&lt;/code&gt; (in Python, or
&lt;code&gt;this&lt;/code&gt; in other object oriented languages).&lt;/p&gt;
&lt;p&gt;Here is Vasudev's first example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let's say we have a class Foo that contains two methods, bar and baz.
We create an instance of the class Foo:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;foo = Foo()
&lt;/pre&gt;


&lt;p&gt;Without method chaining, to call both bar and baz in turn, on the object foo, we would do this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;# Fragment 1
foo.bar() # Call method bar() on object foo.
foo.baz() # Call method baz() on object foo.
&lt;/pre&gt;


&lt;p&gt;With method chaining, we can this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;# Fragment 2
# Chain calls to methods bar() and baz() on object foo.
foo.bar().baz()
&lt;/pre&gt;


&lt;/blockquote&gt;
&lt;p&gt;So the claim for method cascading then is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One advantage of method chaining is that it reduces the number of times you
have to use the name of the object: only once in Fragment 2 above, vs. twice
in Fragment 1; and this difference will increase when there are more method
calls on the same object. Thereby, it also slightly reduces the amount of code
one has to read, understand, test, debug and maintain, overall.
Not major benefits, but can be useful.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So method cascading reduces the number of times you have to use the name of an
object, but this makes it inherently less explicit that you're operating on the
same object. Looking at &lt;code&gt;foo.bar().baz()&lt;/code&gt; does not tell me that &lt;code&gt;baz&lt;/code&gt; is being
called on the same object as &lt;code&gt;bar&lt;/code&gt;. Unless you're keen on method cascading and
use it yourself, it looks like the opposite.&lt;/p&gt;
&lt;p&gt;Method cascading may therefore reduce&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the amount of code one has to read, understand, test, debug and maintain, overall.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However it does so, only in a "code-golf" way. There is no point in reducing
the amount of code to understand if by doing so you increase the difficulty with
which you can understand it.&lt;/p&gt;
&lt;p&gt;A common example of method cascading is one Vasudev includes, that of string
processing. Here we have a line such as (which I've translated into Python 3):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;print ('After uppercase then capitalize:',
        sp.dup().uppercase().capitalize().rep())
&lt;/pre&gt;


&lt;p&gt;Whilst it is quite nice to be able to do this in one line without using a new
variable name, I would write this without method cascading as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;duplicate = sp.dup()
duplicate.uppercase()
duplicate.capitalize()
print('After uppercase then capitalize:', duplicate.rep())
&lt;/pre&gt;


&lt;p&gt;Now it is obvious that &lt;code&gt;dup&lt;/code&gt; returns something new, in this case it is a
duplicate of the original string. It is also clear that &lt;code&gt;uppercase&lt;/code&gt; and
&lt;code&gt;capitalize&lt;/code&gt; do &lt;em&gt;not&lt;/em&gt; return new objects but modify the &lt;code&gt;duplicate&lt;/code&gt; object.&lt;/p&gt;
&lt;p&gt;So, I'm afraid I just don't see the use case for cascading.&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/method-cascading/</guid><pubDate>Tue, 23 Feb 2016 14:54:35 GMT</pubDate></item><item><title>Test First and Mutation Testing</title><link>http://allanderek.github.io/posts/test-first-mutation-testing/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Test First and Mutation Testing&lt;/h2&gt;
&lt;p&gt;I'm going to argue that mutation testing has a strong use in a test first
development environment and I'll conclude by proposing a mechanism to link
mutation testing to the source code control mechanism to further aid test first
development.&lt;/p&gt;
&lt;h3&gt;Test First&lt;/h3&gt;
&lt;p&gt;Just to be clear, when I say 'test first' I mean development in which before
writing a feature, or fixing a bug, you first write a test which should only
pass once you have completed that feature. For the purposes of this post you
needn't be doing that for every line of code you write. The idea here applies
whether you are writing the odd feature by first writing a test for it, or
whether you have a strict policy of writing no code until there is a test for
it.&lt;/p&gt;
&lt;h3&gt;Mutation Testing&lt;/h3&gt;
&lt;p&gt;Mutation testing is the process of automatically changing some parts of your
source code generally to check that your test suite is not indifferent to the
change. For example, your source code may contain a conditional statement
such as the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now if we suppose that the current condition is correct, then changing it to
a similar but different condition, for example &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; or &lt;code&gt;x &amp;gt; 1&lt;/code&gt; then
presumably this would turn correct code into incorrect code. If your tests are
comprehensive then at least one of them should fail due to the now incorrect
code.&lt;/p&gt;
&lt;h3&gt;Fail First&lt;/h3&gt;
&lt;p&gt;It's easy enough to unintentionally write a test that always passes, or perhaps
passes too easily. One of the reasons for writing the test first is to make sure
that it fails when the feature has not yet been implemented (or fixed). However,
often such a test can fail for trivial reasons. For example you may write a unit
test that fails simple because the method it tests is not yet defined. Similarly
a web test may fail because the route is not yet defined. Unless you continue to
run the test during development of your feature you won't necessarily know that
your test is particularly effective at catching when your feature is broken.&lt;/p&gt;
&lt;h3&gt;Fail After&lt;/h3&gt;
&lt;p&gt;Whether you write the test before your new feature or after the feature is
ready, mutation testing can assist with the problem of non-stringent tests.
Mutation testing can assist in reassuring you that your new test is effective at
catching errors, whether those errors are introduced when the feature is
developed or through later changes. If you apply lots of mutations to your code
and your new test never fails then there is a strong likelihood that you have an
ineffective test that passes too easily.&lt;/p&gt;
&lt;h3&gt;Source Code control&lt;/h3&gt;
&lt;p&gt;A feature I would like to add to a mutation test package is to integrate with
a source code control mechanism such as Git. The mutation tester must choose
lines of the program to mutate. However, your new test is presumably aimed at
testing the new code that you write. Hence we could use the source code control
mechanism to mutate lines of code that are newer than the test or some specified
commit. That way we would focus our mutation testing to testing the efficacy of
the new test(s) with respect to the new or changed lines of code.&lt;/p&gt;
&lt;p&gt;This does not preclude doing general mutation testing for features that, for
example, depend upon a lot of existing code. Perhaps your new feature is simply
a display of existing calculations.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mutation testing helps find tests that are ineffective.&lt;/li&gt;
&lt;li&gt;This plays particularly well with a test first development process in which
    the test often fails the first time for trivial reasons, thus giving you
    false assurance that your test can fail.&lt;/li&gt;
&lt;li&gt;Integrating source code control to target the mutations towards new code
    could improve this significantly, or at least make it a bit more convenient.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/test-first-mutation-testing/</guid><pubDate>Fri, 19 Feb 2016 10:14:43 GMT</pubDate></item><item><title>Placement of Python Import Statements</title><link>http://allanderek.github.io/posts/import-placement/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0008/#imports"&gt;Pep 8 specifies&lt;/a&gt;
that all import statements should be "put at the top of the file, just after any
module comments and docstrings, and before module globals and constants."
However, it does not really specify the logic behind this. I'm going to try to
articulate some reasons to have import statements somewhere other than directly
at the top of the file. I'll also state some arguments for having such
&lt;code&gt;import&lt;/code&gt; statements at the top.&lt;/p&gt;
&lt;p&gt;Note, that
&lt;a href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds"&gt;Pep 8 also specifies&lt;/a&gt;
that it is important to "know when to be inconsistent -- sometimes the style guide just doesn't
apply. When in doubt, use your best judgment". So the purpose of this post is to
suggest some reasons why you might deviate from the style guide with respect to
&lt;code&gt;import&lt;/code&gt; statements at the top.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://allanderek.github.io/posts/import-placement/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/import-placement/</guid><pubDate>Wed, 03 Feb 2016 13:08:54 GMT</pubDate></item><item><title>Update: Flask+Coverage</title><link>http://allanderek.github.io/posts/update-flask%2Bcoverage/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Update: Flask+Coverage Analysis&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis"&gt;previous post&lt;/a&gt;
I demonstrated how to get &lt;code&gt;coverage&lt;/code&gt; analysis working for a Flask web application
in a relatively simple manner. In the section &lt;em&gt;"At then end of your tests"&lt;/em&gt; I
stated that you needed your tests to clean-up by telling the server to shutdown.
The end of your test code would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'shutdown'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This could have made things a little fiddly since your test code would have to
make sure to access the &lt;code&gt;shutdown&lt;/code&gt; route exactly once, regardless of how many
tests were run.&lt;/p&gt;
&lt;p&gt;However, I realised that we could remove the burden from the test code by
simply doing this in &lt;code&gt;manage.py&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Updated &lt;code&gt;manage.py&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Previously, we had the following code within our &lt;code&gt;manage.py&lt;/code&gt; script within the
&lt;code&gt;run_with_test_server&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We now update this to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;test_process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'TEST_SERVER_PORT'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;shutdown_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'http://localhost:{}/shutdown'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shutdown_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bytes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="n"&gt;server_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Doing so means you can just write your tests without any need to worry about
shutting down the server.
The &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;
has been appropriately updated.&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/update-flask%2Bcoverage/</guid><pubDate>Tue, 26 Jan 2016 14:59:44 GMT</pubDate></item><item><title>Flask + Coverage Analysis</title><link>http://allanderek.github.io/posts/flask-%2B-coverage-analysis/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Flask + Coverage Analysis&lt;/h2&gt;
&lt;p&gt;This post demonstrates a simple web application written in Flask with coverage
analysis for the tests. The main idea should be pretty translatable into most
Python web application frameworks.&lt;/p&gt;
&lt;h4&gt;Update&lt;/h4&gt;
&lt;p&gt;I've updated this scheme and described the update &lt;a href="http://allanderek.github.io/posts/update-flask%2Bcoverage"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;tl;dr&lt;/h3&gt;
&lt;p&gt;If you're having difficulty getting coverage analysis to work with Flask then
have a look at my &lt;a href="https://github.com/allanderek/flask-coverage-example"&gt;example repository&lt;/a&gt;.
The main take away is that you simply start the server in a process of its own
using &lt;code&gt;coverage&lt;/code&gt; to start it. However, in order for this to work you have to
make sure you can shut the server process down from the test process. To do this
we simply add a new "shutdown" route which is only available under testing. Your
test code, whether written in Python or, say Javascript, can then make a request
to this "shutdown" route once it completes its tests. This allows the server
process to shutdown naturally and therefore allow 'coverage' to complete.&lt;/p&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;It's a good idea to test the web applications you author. Most web application
frameworks provide relatively solid means to do this. However, if you're doing
browser automated functional tests against a live server I've found that getting
&lt;a href="https://pypi.python.org/pypi/coverage"&gt;coverage&lt;/a&gt; to work to be non-trivial. A quick search will reveal similar
difficulties such as &lt;a href="http://stackoverflow.com/questions/23745370/setting-up-coverage-py-with-flask"&gt;this&lt;/a&gt;
stack overflow question, which ultimately points to the &lt;a href="http://coverage.readthedocs.org/en/latest/subprocess.html"&gt;coverage documentation
on sub-processes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Part of the reason for this might be that the Flask-Testing extension provides
live server testing class that starts your server in testing mode as part of
the start-up of the test. It then also shuts the server process down, but in
so doing does not allow coverage to complete.&lt;/p&gt;
&lt;p&gt;A simpler method is to start the server process yourself under coverage. You
then only need a means to shutdown the server programatically. I do this by
adding a &lt;code&gt;shutdown&lt;/code&gt; route.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://allanderek.github.io/posts/flask-%2B-coverage-analysis/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/flask-%2B-coverage-analysis/</guid><pubDate>Mon, 25 Jan 2016 15:20:50 GMT</pubDate></item><item><title>Selenium vs CasperJS</title><link>http://allanderek.github.io/posts/selenium-and-casper/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;p&gt;Suppose you have a web service using a Python web framework such as Flask.
So you wish to do a full user test by automating the browser. Should you use
the Python bindings to Selenium or CasperJS? In this post I wish to detail some
of the advantages and drawbacks of both.&lt;/p&gt;
&lt;h3&gt;Python + Selenium Setup&lt;/h3&gt;
&lt;p&gt;This is fairly straightforward. You are simply writing some Python code that
happens to call a library which binds to Selenium. In order for this to work
you will need to install phantomJS but using &lt;code&gt;npm&lt;/code&gt; this is pretty trivial.&lt;/p&gt;
&lt;h3&gt;Javascript + CasperJS Setup&lt;/h3&gt;
&lt;p&gt;I say Javascript, but at least when I'm using casperJS it tends to be from
Coffeescript, but whichever is your fancy works well enough. Similarly to the
above you will need to install casperJS through the &lt;code&gt;npm&lt;/code&gt; but again this is
pretty trivial.&lt;/p&gt;
&lt;h3&gt;Speed&lt;/h3&gt;
&lt;p&gt;For my sample project the casperJS tests are faster, by quite a bit. This
certainly warrants some more investigation as to exactly why this is the case,
but for now my sample project runs the casperJS tests in around 3 seconds whilst
the Selenium ones take around 12 seconds to do the same amount of work. I'm not
sure whether this is a constant factor or whether it will get worse with more
tests.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://allanderek.github.io/posts/selenium-and-casper/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/selenium-and-casper/</guid><pubDate>Fri, 08 Jan 2016 11:11:40 GMT</pubDate></item><item><title>Welcome</title><link>http://allanderek.github.io/posts/welcome/</link><dc:creator>Allan Clark</dc:creator><description>&lt;div&gt;&lt;h2&gt;Welcome to Coding Diet&lt;/h2&gt;
&lt;p&gt;This is a simple blog intended to be related to good software development
practices, but will probably contain more practical examples that I come across
as I code. I use mainly Python for programming but, since a proportion of the
coding I do is for web development I end up writing CoffeeScript or vanilla
Javascript as well. I'm not averse to other languages as well and have a fairly
strong background in Haskell which I may occasionally refer to as an example.&lt;/p&gt;&lt;/div&gt;</description><guid>http://allanderek.github.io/posts/welcome/</guid><pubDate>Wed, 06 Jan 2016 16:48:42 GMT</pubDate></item></channel></rss>